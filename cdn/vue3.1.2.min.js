var Vue=(function(exports){'use strict';function makeMap(str,expectsLowerCase){const map=Object.create(null);const list=str.split(',');for(let i=0;i<list.length;i++){map[list[i]]=true}return expectsLowerCase?val=>!!map[val.toLowerCase()]:val=>!!map[val]}const PatchFlagNames={[1]:`TEXT`,[2]:`CLASS`,[4]:`STYLE`,[8]:`PROPS`,[16]:`FULL_PROPS`,[32]:`HYDRATE_EVENTS`,[64]:`STABLE_FRAGMENT`,[128]:`KEYED_FRAGMENT`,[256]:`UNKEYED_FRAGMENT`,[512]:`NEED_PATCH`,[1024]:`DYNAMIC_SLOTS`,[2048]:`DEV_ROOT_FRAGMENT`,[-1]:`HOISTED`,[-2]:`BAIL`};const slotFlagsText={[1]:'STABLE',[2]:'DYNAMIC',[3]:'FORWARDED'};const GLOBALS_WHITE_LISTED='Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';const isGloballyWhitelisted=makeMap(GLOBALS_WHITE_LISTED);const range=2;function generateCodeFrame(source,start=0,end=source.length){const lines=source.split(/\r?\n/);let count=0;const res=[];for(let i=0;i<lines.length;i++){count+=lines[i].length+1;if(count>=start){for(let j=i-range;j<=i+range||end>count;j++){if(j<0||j>=lines.length)continue;const line=j+1;res.push(`${line}${' '.repeat(Math.max(3-String(line).length,0))}|${lines[j]}`);const lineLength=lines[j].length;if(j===i){const pad=start-(count-lineLength)+1;const length=Math.max(1,end>count?lineLength-pad:end-start);res.push(`|`+' '.repeat(pad)+'^'.repeat(length))}else if(j>i){if(end>count){const length=Math.max(Math.min(end-count,lineLength),1);res.push(`|`+'^'.repeat(length))}count+=lineLength+1}}break}}return res.join('\n')}const specialBooleanAttrs=`itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;const isSpecialBooleanAttr=makeMap(specialBooleanAttrs);function normalizeStyle(value){if(isArray(value)){const res={};for(let i=0;i<value.length;i++){const item=value[i];const normalized=normalizeStyle(isString(item)?parseStringStyle(item):item);if(normalized){for(const key in normalized){res[key]=normalized[key]}}}return res}else if(isObject(value)){return value}}const listDelimiterRE=/;(?![^(]*\))/g;const propertyDelimiterRE=/:(.+)/;function parseStringStyle(cssText){const ret={};cssText.split(listDelimiterRE).forEach(item=>{if(item){const tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim())}});return ret}function normalizeClass(value){let res='';if(isString(value)){res=value}else if(isArray(value)){for(let i=0;i<value.length;i++){const normalized=normalizeClass(value[i]);if(normalized){res+=normalized+' '}}}else if(isObject(value)){for(const name in value){if(value[name]){res+=name+' '}}}return res.trim()}const HTML_TAGS='html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot';const SVG_TAGS='svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view';const VOID_TAGS='area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';const isHTMLTag=makeMap(HTML_TAGS);const isSVGTag=makeMap(SVG_TAGS);const isVoidTag=makeMap(VOID_TAGS);function looseCompareArrays(a,b){if(a.length!==b.length)return false;let equal=true;for(let i=0;equal&&i<a.length;i++){equal=looseEqual(a[i],b[i])}return equal}function looseEqual(a,b){if(a===b)return true;let aValidType=isDate(a);let bValidType=isDate(b);if(aValidType||bValidType){return aValidType&&bValidType?a.getTime()===b.getTime():false}aValidType=isArray(a);bValidType=isArray(b);if(aValidType||bValidType){return aValidType&&bValidType?looseCompareArrays(a,b):false}aValidType=isObject(a);bValidType=isObject(b);if(aValidType||bValidType){if(!aValidType||!bValidType){return false}const aKeysCount=Object.keys(a).length;const bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount){return false}for(const key in a){const aHasKey=a.hasOwnProperty(key);const bHasKey=b.hasOwnProperty(key);if((aHasKey&&!bHasKey)||(!aHasKey&&bHasKey)||!looseEqual(a[key],b[key])){return false}}}return String(a)===String(b)}function looseIndexOf(arr,val){return arr.findIndex(item=>looseEqual(item,val))}const toDisplayString=(val)=>{return val==null?'':isObject(val)?JSON.stringify(val,replacer,2):String(val)};const replacer=(_key,val)=>{if(isMap(val)){return{[`Map(${val.size})`]:[...val.entries()].reduce((entries,[key,val])=>{entries[`${key}=>`]=val;return entries},{})}}else if(isSet(val)){return{[`Set(${val.size})`]:[...val.values()]}}else if(isObject(val)&&!isArray(val)&&!isPlainObject(val)){return String(val)}return val};const EMPTY_OBJ=Object.freeze({});const EMPTY_ARR=Object.freeze([]);const NOOP=()=>{};const NO=()=>false;const onRE=/^on[^a-z]/;const isOn=(key)=>onRE.test(key);const isModelListener=(key)=>key.startsWith('onUpdate:');const extend=Object.assign;const remove=(arr,el)=>{const i=arr.indexOf(el);if(i>-1){arr.splice(i,1)}};const hasOwnProperty=Object.prototype.hasOwnProperty;const hasOwn=(val,key)=>hasOwnProperty.call(val,key);const isArray=Array.isArray;const isMap=(val)=>toTypeString(val)==='[object Map]';const isSet=(val)=>toTypeString(val)==='[object Set]';const isDate=(val)=>val instanceof Date;const isFunction=(val)=>typeof val==='function';const isString=(val)=>typeof val==='string';const isSymbol=(val)=>typeof val==='symbol';const isObject=(val)=>val!==null&&typeof val==='object';const isPromise=(val)=>{return isObject(val)&&isFunction(val.then)&&isFunction(val.catch)};const objectToString=Object.prototype.toString;const toTypeString=(value)=>objectToString.call(value);const toRawType=(value)=>{return toTypeString(value).slice(8,-1)};const isPlainObject=(val)=>toTypeString(val)==='[object Object]';const isIntegerKey=(key)=>isString(key)&&key!=='NaN'&&key[0]!=='-'&&''+parseInt(key,10)===key;const isReservedProp=makeMap(',key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted');const cacheStringFunction=(fn)=>{const cache=Object.create(null);return((str)=>{const hit=cache[str];return hit||(cache[str]=fn(str))})};const camelizeRE=/-(\w)/g;const camelize=cacheStringFunction((str)=>{return str.replace(camelizeRE,(_,c)=>(c?c.toUpperCase():''))});const hyphenateRE=/\B([A-Z])/g;const hyphenate=cacheStringFunction((str)=>str.replace(hyphenateRE,'-$1').toLowerCase());const capitalize=cacheStringFunction((str)=>str.charAt(0).toUpperCase()+str.slice(1));const toHandlerKey=cacheStringFunction((str)=>(str?`on${capitalize(str)}`:``));const hasChanged=(value,oldValue)=>value!==oldValue&&(value===value||oldValue===oldValue);const invokeArrayFns=(fns,arg)=>{for(let i=0;i<fns.length;i++){fns[i](arg)}};const def=(obj,key,value)=>{Object.defineProperty(obj,key,{configurable:true,enumerable:false,value})};const toNumber=(val)=>{const n=parseFloat(val);return isNaN(n)?val:n};let _globalThis;const getGlobalThis=()=>{return(_globalThis||(_globalThis=typeof globalThis!=='undefined'?globalThis:typeof self!=='undefined'?self:typeof window!=='undefined'?window:typeof global!=='undefined'?global:{}))};const targetMap=new WeakMap();const effectStack=[];let activeEffect;const ITERATE_KEY=Symbol('iterate');const MAP_KEY_ITERATE_KEY=Symbol('Map key iterate');function isEffect(fn){return fn&&fn._isEffect===true}function effect(fn,options=EMPTY_OBJ){if(isEffect(fn)){fn=fn.raw}const effect=createReactiveEffect(fn,options);if(!options.lazy){effect()}return effect}function stop(effect){if(effect.active){cleanup(effect);if(effect.options.onStop){effect.options.onStop()}effect.active=false}}let uid=0;function createReactiveEffect(fn,options){const effect=function reactiveEffect(){if(!effect.active){return fn()}if(!effectStack.includes(effect)){cleanup(effect);try{enableTracking();effectStack.push(effect);activeEffect=effect;return fn()}finally{effectStack.pop();resetTracking();activeEffect=effectStack[effectStack.length-1]}}};effect.id=uid++;effect.allowRecurse=!!options.allowRecurse;effect._isEffect=true;effect.active=true;effect.raw=fn;effect.deps=[];effect.options=options;return effect}function cleanup(effect){const{deps}=effect;if(deps.length){for(let i=0;i<deps.length;i++){deps[i].delete(effect)}deps.length=0}}let shouldTrack=true;const trackStack=[];function pauseTracking(){trackStack.push(shouldTrack);shouldTrack=false}function enableTracking(){trackStack.push(shouldTrack);shouldTrack=true}function resetTracking(){const last=trackStack.pop();shouldTrack=last===undefined?true:last}function track(target,type,key){if(!shouldTrack||activeEffect===undefined){return}let depsMap=targetMap.get(target);if(!depsMap){targetMap.set(target,(depsMap=new Map()))}let dep=depsMap.get(key);if(!dep){depsMap.set(key,(dep=new Set()))}if(!dep.has(activeEffect)){dep.add(activeEffect);activeEffect.deps.push(dep);if(activeEffect.options.onTrack){activeEffect.options.onTrack({effect:activeEffect,target,type,key})}}}function trigger(target,type,key,newValue,oldValue,oldTarget){const depsMap=targetMap.get(target);if(!depsMap){return}const effects=new Set();const add=(effectsToAdd)=>{if(effectsToAdd){effectsToAdd.forEach(effect=>{if(effect!==activeEffect||effect.allowRecurse){effects.add(effect)}})}};if(type==="clear"){depsMap.forEach(add)}else if(key==='length'&&isArray(target)){depsMap.forEach((dep,key)=>{if(key==='length'||key>=newValue){add(dep)}})}else{if(key!==void 0){add(depsMap.get(key))}switch(type){case"add":if(!isArray(target)){add(depsMap.get(ITERATE_KEY));if(isMap(target)){add(depsMap.get(MAP_KEY_ITERATE_KEY))}}else if(isIntegerKey(key)){add(depsMap.get('length'))}break;case"delete":if(!isArray(target)){add(depsMap.get(ITERATE_KEY));if(isMap(target)){add(depsMap.get(MAP_KEY_ITERATE_KEY))}}break;case"set":if(isMap(target)){add(depsMap.get(ITERATE_KEY))}break}}const run=(effect)=>{if(effect.options.onTrigger){effect.options.onTrigger({effect,target,key,type,newValue,oldValue,oldTarget})}if(effect.options.scheduler){effect.options.scheduler(effect)}else{effect()}};effects.forEach(run)}const isNonTrackableKeys=makeMap(`__proto__,__v_isRef,__isVue`);const builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).map(key=>Symbol[key]).filter(isSymbol));const get=createGetter();const shallowGet=createGetter(false,true);const readonlyGet=createGetter(true);const shallowReadonlyGet=createGetter(true,true);const arrayInstrumentations={};['includes','indexOf','lastIndexOf'].forEach(key=>{const method=Array.prototype[key];arrayInstrumentations[key]=function(...args){const arr=toRaw(this);for(let i=0,l=this.length;i<l;i++){track(arr,"get",i+'')}const res=method.apply(arr,args);if(res===-1||res===false){return method.apply(arr,args.map(toRaw))}else{return res}}});['push','pop','shift','unshift','splice'].forEach(key=>{const method=Array.prototype[key];arrayInstrumentations[key]=function(...args){pauseTracking();const res=method.apply(this,args);resetTracking();return res}});function createGetter(isReadonly=false,shallow=false){return function get(target,key,receiver){if(key==="__v_isReactive"){return!isReadonly}else if(key==="__v_isReadonly"){return isReadonly}else if(key==="__v_raw"&&receiver===(isReadonly?shallow?shallowReadonlyMap:readonlyMap:shallow?shallowReactiveMap:reactiveMap).get(target)){return target}const targetIsArray=isArray(target);if(!isReadonly&&targetIsArray&&hasOwn(arrayInstrumentations,key)){return Reflect.get(arrayInstrumentations,key,receiver)}const res=Reflect.get(target,key,receiver);if(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key)){return res}if(!isReadonly){track(target,"get",key)}if(shallow){return res}if(isRef(res)){const shouldUnwrap=!targetIsArray||!isIntegerKey(key);return shouldUnwrap?res.value:res}if(isObject(res)){return isReadonly?readonly(res):reactive(res)}return res}}const set=createSetter();const shallowSet=createSetter(true);function createSetter(shallow=false){return function set(target,key,value,receiver){let oldValue=target[key];if(!shallow){value=toRaw(value);oldValue=toRaw(oldValue);if(!isArray(target)&&isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true}}const hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key);const result=Reflect.set(target,key,value,receiver);if(target===toRaw(receiver)){if(!hadKey){trigger(target,"add",key,value)}else if(hasChanged(value,oldValue)){trigger(target,"set",key,value,oldValue)}}return result}}function deleteProperty(target,key){const hadKey=hasOwn(target,key);const oldValue=target[key];const result=Reflect.deleteProperty(target,key);if(result&&hadKey){trigger(target,"delete",key,undefined,oldValue)}return result}function has(target,key){const result=Reflect.has(target,key);if(!isSymbol(key)||!builtInSymbols.has(key)){track(target,"has",key)}return result}function ownKeys(target){track(target,"iterate",isArray(target)?'length':ITERATE_KEY);return Reflect.ownKeys(target)}const mutableHandlers={get,set,deleteProperty,has,ownKeys};const readonlyHandlers={get:readonlyGet,set(target,key){{console.warn(`Set operation on key"${String(key)}"failed:target is readonly.`,target)}return true},deleteProperty(target,key){{console.warn(`Delete operation on key"${String(key)}"failed:target is readonly.`,target)}return true}};const shallowReactiveHandlers=extend({},mutableHandlers,{get:shallowGet,set:shallowSet});const shallowReadonlyHandlers=extend({},readonlyHandlers,{get:shallowReadonlyGet});const toReactive=(value)=>isObject(value)?reactive(value):value;const toReadonly=(value)=>isObject(value)?readonly(value):value;const toShallow=(value)=>value;const getProto=(v)=>Reflect.getPrototypeOf(v);function get$1(target,key,isReadonly=false,isShallow=false){target=target["__v_raw"];const rawTarget=toRaw(target);const rawKey=toRaw(key);if(key!==rawKey){!isReadonly&&track(rawTarget,"get",key)}!isReadonly&&track(rawTarget,"get",rawKey);const{has}=getProto(rawTarget);const wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;if(has.call(rawTarget,key)){return wrap(target.get(key))}else if(has.call(rawTarget,rawKey)){return wrap(target.get(rawKey))}else if(target!==rawTarget){target.get(key)}}function has$1(key,isReadonly=false){const target=this["__v_raw"];const rawTarget=toRaw(target);const rawKey=toRaw(key);if(key!==rawKey){!isReadonly&&track(rawTarget,"has",key)}!isReadonly&&track(rawTarget,"has",rawKey);return key===rawKey?target.has(key):target.has(key)||target.has(rawKey)}function size(target,isReadonly=false){target=target["__v_raw"];!isReadonly&&track(toRaw(target),"iterate",ITERATE_KEY);return Reflect.get(target,'size',target)}function add(value){value=toRaw(value);const target=toRaw(this);const proto=getProto(target);const hadKey=proto.has.call(target,value);if(!hadKey){target.add(value);trigger(target,"add",value,value)}return this}function set$1(key,value){value=toRaw(value);const target=toRaw(this);const{has,get}=getProto(target);let hadKey=has.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has.call(target,key)}else{checkIdentityKeys(target,has,key)}const oldValue=get.call(target,key);target.set(key,value);if(!hadKey){trigger(target,"add",key,value)}else if(hasChanged(value,oldValue)){trigger(target,"set",key,value,oldValue)}return this}function deleteEntry(key){const target=toRaw(this);const{has,get}=getProto(target);let hadKey=has.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has.call(target,key)}else{checkIdentityKeys(target,has,key)}const oldValue=get?get.call(target,key):undefined;const result=target.delete(key);if(hadKey){trigger(target,"delete",key,undefined,oldValue)}return result}function clear(){const target=toRaw(this);const hadItems=target.size!==0;const oldTarget=isMap(target)?new Map(target):new Set(target);const result=target.clear();if(hadItems){trigger(target,"clear",undefined,undefined,oldTarget)}return result}function createForEach(isReadonly,isShallow){return function forEach(callback,thisArg){const observed=this;const target=observed["__v_raw"];const rawTarget=toRaw(target);const wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;!isReadonly&&track(rawTarget,"iterate",ITERATE_KEY);return target.forEach((value,key)=>{return callback.call(thisArg,wrap(value),wrap(key),observed)})}}function createIterableMethod(method,isReadonly,isShallow){return function(...args){const target=this["__v_raw"];const rawTarget=toRaw(target);const targetIsMap=isMap(rawTarget);const isPair=method==='entries'||(method===Symbol.iterator&&targetIsMap);const isKeyOnly=method==='keys'&&targetIsMap;const innerIterator=target[method](...args);const wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;!isReadonly&&track(rawTarget,"iterate",isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY);return{next(){const{value,done}=innerIterator.next();return done?{value,done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done}},[Symbol.iterator](){return this}}}}function createReadonlyMethod(type){return function(...args){{const key=args[0]?`on key"${args[0]}"`:``;console.warn(`${capitalize(type)}operation ${key}failed:target is readonly.`,toRaw(this))}return type==="delete"?false:this}}const mutableInstrumentations={get(key){return get$1(this,key)},get size(){return size(this)},has:has$1,add,set:set$1,delete:deleteEntry,clear,forEach:createForEach(false,false)};const shallowInstrumentations={get(key){return get$1(this,key,false,true)},get size(){return size(this)},has:has$1,add,set:set$1,delete:deleteEntry,clear,forEach:createForEach(false,true)};const readonlyInstrumentations={get(key){return get$1(this,key,true)},get size(){return size(this,true)},has(key){return has$1.call(this,key,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,false)};const shallowReadonlyInstrumentations={get(key){return get$1(this,key,true,true)},get size(){return size(this,true)},has(key){return has$1.call(this,key,true)},add:createReadonlyMethod("add"),set:createReadonlyMethod("set"),delete:createReadonlyMethod("delete"),clear:createReadonlyMethod("clear"),forEach:createForEach(true,true)};const iteratorMethods=['keys','values','entries',Symbol.iterator];iteratorMethods.forEach(method=>{mutableInstrumentations[method]=createIterableMethod(method,false,false);readonlyInstrumentations[method]=createIterableMethod(method,true,false);shallowInstrumentations[method]=createIterableMethod(method,false,true);shallowReadonlyInstrumentations[method]=createIterableMethod(method,true,true)});function createInstrumentationGetter(isReadonly,shallow){const instrumentations=shallow?isReadonly?shallowReadonlyInstrumentations:shallowInstrumentations:isReadonly?readonlyInstrumentations:mutableInstrumentations;return(target,key,receiver)=>{if(key==="__v_isReactive"){return!isReadonly}else if(key==="__v_isReadonly"){return isReadonly}else if(key==="__v_raw"){return target}return Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver)}}const mutableCollectionHandlers={get:createInstrumentationGetter(false,false)};const shallowCollectionHandlers={get:createInstrumentationGetter(false,true)};const readonlyCollectionHandlers={get:createInstrumentationGetter(true,false)};const shallowReadonlyCollectionHandlers={get:createInstrumentationGetter(true,true)};function checkIdentityKeys(target,has,key){const rawKey=toRaw(key);if(rawKey!==key&&has.call(target,rawKey)){const type=toRawType(target);console.warn(`Reactive ${type}contains both the raw and reactive`+`versions of the same object${type===`Map`?`as keys`:``},`+`which can lead to inconsistencies.`+`Avoid differentiating between the raw and reactive versions`+`of an object and only use the reactive version if possible.`)}}const reactiveMap=new WeakMap();const shallowReactiveMap=new WeakMap();const readonlyMap=new WeakMap();const shallowReadonlyMap=new WeakMap();function targetTypeMap(rawType){switch(rawType){case'Object':case'Array':return 1;case'Map':case'Set':case'WeakMap':case'WeakSet':return 2;default:return 0}}function getTargetType(value){return value["__v_skip"]||!Object.isExtensible(value)?0:targetTypeMap(toRawType(value))}function reactive(target){if(target&&target["__v_isReadonly"]){return target}return createReactiveObject(target,false,mutableHandlers,mutableCollectionHandlers,reactiveMap)}function shallowReactive(target){return createReactiveObject(target,false,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap)}function readonly(target){return createReactiveObject(target,true,readonlyHandlers,readonlyCollectionHandlers,readonlyMap)}function shallowReadonly(target){return createReactiveObject(target,true,shallowReadonlyHandlers,shallowReadonlyCollectionHandlers,shallowReadonlyMap)}function createReactiveObject(target,isReadonly,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target)){{console.warn(`value cannot be made reactive:${String(target)}`)}return target}if(target["__v_raw"]&&!(isReadonly&&target["__v_isReactive"])){return target}const existingProxy=proxyMap.get(target);if(existingProxy){return existingProxy}const targetType=getTargetType(target);if(targetType===0){return target}const proxy=new Proxy(target,targetType===2?collectionHandlers:baseHandlers);proxyMap.set(target,proxy);return proxy}function isReactive(value){if(isReadonly(value)){return isReactive(value["__v_raw"])}return!!(value&&value["__v_isReactive"])}function isReadonly(value){return!!(value&&value["__v_isReadonly"])}function isProxy(value){return isReactive(value)||isReadonly(value)}function toRaw(observed){return((observed&&toRaw(observed["__v_raw"]))||observed)}function markRaw(value){def(value,"__v_skip",true);return value}const convert=(val)=>isObject(val)?reactive(val):val;function isRef(r){return Boolean(r&&r.__v_isRef===true)}function ref(value){return createRef(value)}function shallowRef(value){return createRef(value,true)}class RefImpl{constructor(_rawValue,_shallow){this._rawValue=_rawValue;this._shallow=_shallow;this.__v_isRef=true;this._value=_shallow?_rawValue:convert(_rawValue)}get value(){track(toRaw(this),"get",'value');return this._value}set value(newVal){if(hasChanged(toRaw(newVal),this._rawValue)){this._rawValue=newVal;this._value=this._shallow?newVal:convert(newVal);trigger(toRaw(this),"set",'value',newVal)}}}function createRef(rawValue,shallow=false){if(isRef(rawValue)){return rawValue}return new RefImpl(rawValue,shallow)}function triggerRef(ref){trigger(toRaw(ref),"set",'value',ref.value)}function unref(ref){return isRef(ref)?ref.value:ref}const shallowUnwrapHandlers={get:(target,key,receiver)=>unref(Reflect.get(target,key,receiver)),set:(target,key,value,receiver)=>{const oldValue=target[key];if(isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true}else{return Reflect.set(target,key,value,receiver)}}};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers)}class CustomRefImpl{constructor(factory){this.__v_isRef=true;const{get,set}=factory(()=>track(this,"get",'value'),()=>trigger(this,"set",'value'));this._get=get;this._set=set}get value(){return this._get()}set value(newVal){this._set(newVal)}}function customRef(factory){return new CustomRefImpl(factory)}function toRefs(object){if(!isProxy(object)){console.warn(`toRefs()expects a reactive object but received a plain one.`)}const ret=isArray(object)?new Array(object.length):{};for(const key in object){ret[key]=toRef(object,key)}return ret}class ObjectRefImpl{constructor(_object,_key){this._object=_object;this._key=_key;this.__v_isRef=true}get value(){return this._object[this._key]}set value(newVal){this._object[this._key]=newVal}}function toRef(object,key){return isRef(object[key])?object[key]:new ObjectRefImpl(object,key)}class ComputedRefImpl{constructor(getter,_setter,isReadonly){this._setter=_setter;this._dirty=true;this.__v_isRef=true;this.effect=effect(getter,{lazy:true,scheduler:()=>{if(!this._dirty){this._dirty=true;trigger(toRaw(this),"set",'value')}}});this["__v_isReadonly"]=isReadonly}get value(){const self=toRaw(this);if(self._dirty){self._value=this.effect();self._dirty=false}track(self,"get",'value');return self._value}set value(newValue){this._setter(newValue)}}function computed(getterOrOptions){let getter;let setter;if(isFunction(getterOrOptions)){getter=getterOrOptions;setter=()=>{console.warn('Write operation failed: computed value is readonly')}}else{getter=getterOrOptions.get;setter=getterOrOptions.set}return new ComputedRefImpl(getter,setter,isFunction(getterOrOptions)||!getterOrOptions.set)}const stack=[];function pushWarningContext(vnode){stack.push(vnode)}function popWarningContext(){stack.pop()}function warn(msg,...args){pauseTracking();const instance=stack.length?stack[stack.length-1].component:null;const appWarnHandler=instance&&instance.appContext.config.warnHandler;const trace=getComponentTrace();if(appWarnHandler){callWithErrorHandling(appWarnHandler,instance,11,[msg+args.join(''),instance&&instance.proxy,trace.map(({vnode})=>`at<${formatComponentName(instance,vnode.type)}>`).join('\n'),trace])}else{const warnArgs=[`[Vue warn]:${msg}`,...args];if(trace.length&&!false){warnArgs.push(`\n`,...formatTrace(trace))}console.warn(...warnArgs)}resetTracking()}function getComponentTrace(){let currentVNode=stack[stack.length-1];if(!currentVNode){return[]}const normalizedStack=[];while(currentVNode){const last=normalizedStack[0];if(last&&last.vnode===currentVNode){last.recurseCount++}else{normalizedStack.push({vnode:currentVNode,recurseCount:0})}const parentInstance=currentVNode.component&&currentVNode.component.parent;currentVNode=parentInstance&&parentInstance.vnode}return normalizedStack}function formatTrace(trace){const logs=[];trace.forEach((entry,i)=>{logs.push(...(i===0?[]:[`\n`]),...formatTraceEntry(entry))});return logs}function formatTraceEntry({vnode,recurseCount}){const postfix=recurseCount>0?`...(${recurseCount}recursive calls)`:``;const isRoot=vnode.component?vnode.component.parent==null:false;const open=`at<${formatComponentName(vnode.component,vnode.type,isRoot)}`;const close=`>`+postfix;return vnode.props?[open,...formatProps(vnode.props),close]:[open+close]}function formatProps(props){const res=[];const keys=Object.keys(props);keys.slice(0,3).forEach(key=>{res.push(...formatProp(key,props[key]))});if(keys.length>3){res.push(`...`)}return res}function formatProp(key,value,raw){if(isString(value)){value=JSON.stringify(value);return raw?value:[`${key}=${value}`]}else if(typeof value==='number'||typeof value==='boolean'||value==null){return raw?value:[`${key}=${value}`]}else if(isRef(value)){value=formatProp(key,toRaw(value.value),true);return raw?value:[`${key}=Ref<`,value,`>`]}else if(isFunction(value)){return[`${key}=fn${value.name?`<${value.name}>`:``}`]}else{value=toRaw(value);return raw?value:[`${key}=`,value]}}const ErrorTypeStrings={["bc"]:'beforeCreate hook',["c"]:'created hook',["bm"]:'beforeMount hook',["m"]:'mounted hook',["bu"]:'beforeUpdate hook',["u"]:'updated',["bum"]:'beforeUnmount hook',["um"]:'unmounted hook',["a"]:'activated hook',["da"]:'deactivated hook',["ec"]:'errorCaptured hook',["rtc"]:'renderTracked hook',["rtg"]:'renderTriggered hook',[0]:'setup function',[1]:'render function',[2]:'watcher getter',[3]:'watcher callback',[4]:'watcher cleanup function',[5]:'native event handler',[6]:'component event handler',[7]:'vnode hook',[8]:'directive hook',[9]:'transition hook',[10]:'app errorHandler',[11]:'app warnHandler',[12]:'ref function',[13]:'async component loader',[14]:'scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next'};function callWithErrorHandling(fn,instance,type,args){let res;try{res=args?fn(...args):fn()}catch(err){handleError(err,instance,type)}return res}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){const res=callWithErrorHandling(fn,instance,type,args);if(res&&isPromise(res)){res.catch(err=>{handleError(err,instance,type)})}return res}const values=[];for(let i=0;i<fn.length;i++){values.push(callWithAsyncErrorHandling(fn[i],instance,type,args))}return values}function handleError(err,instance,type,throwInDev=true){const contextVNode=instance?instance.vnode:null;if(instance){let cur=instance.parent;const exposedInstance=instance.proxy;const errorInfo=ErrorTypeStrings[type];while(cur){const errorCapturedHooks=cur.ec;if(errorCapturedHooks){for(let i=0;i<errorCapturedHooks.length;i++){if(errorCapturedHooks[i](err,exposedInstance,errorInfo)===false){return}}}cur=cur.parent}const appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler){callWithErrorHandling(appErrorHandler,null,10,[err,exposedInstance,errorInfo]);return}}logError(err,type,contextVNode,throwInDev);}function logError(err,type,contextVNode,throwInDev=true){{const info=ErrorTypeStrings[type];if(contextVNode){pushWarningContext(contextVNode)}warn(`Unhandled error${info?`during execution of ${info}`:``}`);if(contextVNode){popWarningContext()}if(throwInDev){throw err;}else{console.error(err)}}}let isFlushing=false;let isFlushPending=false;const queue=[];let flushIndex=0;const pendingPreFlushCbs=[];let activePreFlushCbs=null;let preFlushIndex=0;const pendingPostFlushCbs=[];let activePostFlushCbs=null;let postFlushIndex=0;const resolvedPromise=Promise.resolve();let currentFlushPromise=null;let currentPreFlushParentJob=null;const RECURSION_LIMIT=100;function nextTick(fn){const p=currentFlushPromise||resolvedPromise;return fn?p.then(this?fn.bind(this):fn):p}function findInsertionIndex(job){let start=flushIndex+1;let end=queue.length;const jobId=getId(job);while(start<end){const middle=(start+end)>>>1;const middleJobId=getId(queue[middle]);middleJobId<jobId?(start=middle+1):(end=middle)}return start}function queueJob(job){if((!queue.length||!queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex))&&job!==currentPreFlushParentJob){const pos=findInsertionIndex(job);if(pos>-1){queue.splice(pos,0,job)}else{queue.push(job)}queueFlush()}}function queueFlush(){if(!isFlushing&&!isFlushPending){isFlushPending=true;currentFlushPromise=resolvedPromise.then(flushJobs)}}function invalidateJob(job){const i=queue.indexOf(job);if(i>flushIndex){queue.splice(i,1)}}function queueCb(cb,activeQueue,pendingQueue,index){if(!isArray(cb)){if(!activeQueue||!activeQueue.includes(cb,cb.allowRecurse?index+1:index)){pendingQueue.push(cb)}}else{pendingQueue.push(...cb)}queueFlush()}function queuePreFlushCb(cb){queueCb(cb,activePreFlushCbs,pendingPreFlushCbs,preFlushIndex)}function queuePostFlushCb(cb){queueCb(cb,activePostFlushCbs,pendingPostFlushCbs,postFlushIndex)}function flushPreFlushCbs(seen,parentJob=null){if(pendingPreFlushCbs.length){currentPreFlushParentJob=parentJob;activePreFlushCbs=[...new Set(pendingPreFlushCbs)];pendingPreFlushCbs.length=0;{seen=seen||new Map()}for(preFlushIndex=0;preFlushIndex<activePreFlushCbs.length;preFlushIndex++){if(checkRecursiveUpdates(seen,activePreFlushCbs[preFlushIndex])){continue}activePreFlushCbs[preFlushIndex]()}activePreFlushCbs=null;preFlushIndex=0;currentPreFlushParentJob=null;flushPreFlushCbs(seen,parentJob)}}function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){const deduped=[...new Set(pendingPostFlushCbs)];pendingPostFlushCbs.length=0;if(activePostFlushCbs){activePostFlushCbs.push(...deduped);return}activePostFlushCbs=deduped;{seen=seen||new Map()}activePostFlushCbs.sort((a,b)=>getId(a)-getId(b));for(postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++){if(checkRecursiveUpdates(seen,activePostFlushCbs[postFlushIndex])){continue}activePostFlushCbs[postFlushIndex]()}activePostFlushCbs=null;postFlushIndex=0}}const getId=(job)=>job.id==null?Infinity:job.id;function flushJobs(seen){isFlushPending=false;isFlushing=true;{seen=seen||new Map()}flushPreFlushCbs(seen);queue.sort((a,b)=>getId(a)-getId(b));try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){const job=queue[flushIndex];if(job&&job.active!==false){if(true&&checkRecursiveUpdates(seen,job)){continue}callWithErrorHandling(job,null,14)}}}finally{flushIndex=0;queue.length=0;flushPostFlushCbs(seen);isFlushing=false;currentFlushPromise=null;if(queue.length||pendingPreFlushCbs.length||pendingPostFlushCbs.length){flushJobs(seen)}}}function checkRecursiveUpdates(seen,fn){if(!seen.has(fn)){seen.set(fn,1)}else{const count=seen.get(fn);if(count>RECURSION_LIMIT){const instance=fn.ownerInstance;const componentName=instance&&getComponentName(instance.type);warn(`Maximum recursive updates exceeded${componentName?`in component<${componentName}>`:``}.`+`This means you have a reactive effect that is mutating its own`+`dependencies and thus recursively triggering itself.Possible sources`+`include component template,render function,updated hook or`+`watcher source function.`);return true}else{seen.set(fn,count+1)}}}let isHmrUpdating=false;const hmrDirtyComponents=new Set();{const globalObject=typeof global!=='undefined'?global:typeof self!=='undefined'?self:typeof window!=='undefined'?window:{};globalObject.__VUE_HMR_RUNTIME__={createRecord:tryWrap(createRecord),rerender:tryWrap(rerender),reload:tryWrap(reload)}}const map=new Map();function registerHMR(instance){const id=instance.type.__hmrId;let record=map.get(id);if(!record){createRecord(id,instance.type);record=map.get(id)}record.instances.add(instance)}function unregisterHMR(instance){map.get(instance.type.__hmrId).instances.delete(instance)}function createRecord(id,component){if(!component){warn(`HMR API usage is out of date.\n`+`Please upgrade vue-loader/vite/rollup-plugin-vue or other relevant`+`dependency that handles Vue SFC compilation.`);component={}}if(map.has(id)){return false}map.set(id,{component:isClassComponent(component)?component.__vccOpts:component,instances:new Set()});return true}function rerender(id,newRender){const record=map.get(id);if(!record)return;if(newRender)record.component.render=newRender;Array.from(record.instances).forEach(instance=>{if(newRender){instance.render=newRender}instance.renderCache=[];isHmrUpdating=true;instance.update();isHmrUpdating=false})}function reload(id,newComp){const record=map.get(id);if(!record)return;const{component,instances}=record;if(!hmrDirtyComponents.has(component)){newComp=isClassComponent(newComp)?newComp.__vccOpts:newComp;extend(component,newComp);for(const key in component){if(key!=='__file'&&!(key in newComp)){delete component[key]}}hmrDirtyComponents.add(component);queuePostFlushCb(()=>{hmrDirtyComponents.delete(component)})}Array.from(instances).forEach(instance=>{if(instance.parent){queueJob(instance.parent.update)}else if(instance.appContext.reload){instance.appContext.reload()}else if(typeof window!=='undefined'){window.location.reload()}else{console.warn('[HMR] Root or manually mounted instance modified. Full reload required.')}})}function tryWrap(fn){return(id,arg)=>{try{return fn(id,arg)}catch(e){console.error(e);console.warn(`[HMR]Something went wrong during Vue component hot-reload.`+`Full reload required.`)}}}function setDevtoolsHook(hook){exports.devtools=hook}function devtoolsInitApp(app,version){if(!exports.devtools)return;exports.devtools.emit("app:init",app,version,{Fragment,Text,Comment:Comment$1,Static})}function devtoolsUnmountApp(app){if(!exports.devtools)return;exports.devtools.emit("app:unmount",app)}const devtoolsComponentAdded=createDevtoolsComponentHook("component:added");const devtoolsComponentUpdated=createDevtoolsComponentHook("component:updated");const devtoolsComponentRemoved=createDevtoolsComponentHook("component:removed");function createDevtoolsComponentHook(hook){return(component)=>{if(!exports.devtools)return;exports.devtools.emit(hook,component.appContext.app,component.uid,component.parent?component.parent.uid:undefined,component)}}const devtoolsPerfStart=createDevtoolsPerformanceHook("perf:start");const devtoolsPerfEnd=createDevtoolsPerformanceHook("perf:end");function createDevtoolsPerformanceHook(hook){return(component,type,time)=>{if(!exports.devtools)return;exports.devtools.emit(hook,component.appContext.app,component.uid,component,type,time)}}function devtoolsComponentEmit(component,event,params){if(!exports.devtools)return;exports.devtools.emit("component:emit",component.appContext.app,component,event,params)}const deprecationData={["GLOBAL_MOUNT"]:{message:`The global app bootstrapping API has changed:vm.$mount()and the"el"`+`option have been removed.Use createApp(RootComponent).mount()instead.`,link:`https:},["GLOBAL_MOUNT_CONTAINER"]:{message:`Vue detected directives on the mount container.`+`In Vue 3,the container is no longer considered part of the template`+`and will not be processed/replaced.`,link:`https:},["GLOBAL_EXTEND"]:{message:`Vue.extend()has been removed in Vue 3.`+`Use defineComponent()instead.`,link:`https:},["GLOBAL_PROTOTYPE"]:{message:`Vue.prototype is no longer available in Vue 3.`+`Use app.config.globalProperties instead.`,link:`https:},["GLOBAL_SET"]:{message:`Vue.set()has been removed as it is no longer needed in Vue 3.`+`Simply use native JavaScript mutations.`},["GLOBAL_DELETE"]:{message:`Vue.delete()has been removed as it is no longer needed in Vue 3.`+`Simply use native JavaScript mutations.`},["GLOBAL_OBSERVABLE"]:{message:`Vue.observable()has been removed.`+`Use\`import{reactive}from"vue"\`from Composition API instead.`,link:`https:},["GLOBAL_PRIVATE_UTIL"]:{message:`Vue.util has been removed.Please refactor to avoid its usage`+`since it was an internal API even in Vue 2.`},["CONFIG_SILENT"]:{message:`config.silent has been removed because it is not good practice to`+`intentionally suppress warnings.You can use your browser console's ` +
              `filter features to focus on relevant messages.`
      },
      ["CONFIG_DEVTOOLS" /* CONFIG_DEVTOOLS */]: {
          message: `config.devtools has been removed. To enable devtools for ` +
              `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
          link: `https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags`
      },
      ["CONFIG_KEY_CODES" /* CONFIG_KEY_CODES */]: {
          message: `config.keyCodes has been removed. ` +
              `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
          link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
      },
      ["CONFIG_PRODUCTION_TIP" /* CONFIG_PRODUCTION_TIP */]: {
          message: `config.productionTip has been removed.`,
          link: `https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed`
      },
      ["CONFIG_IGNORED_ELEMENTS" /* CONFIG_IGNORED_ELEMENTS */]: {
          message: () => {
              let msg = `config.ignoredElements has been removed.`;
              if (isRuntimeOnly()) {
                  msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
              }
              else {
                  msg += ` Use config.isCustomElement instead.`;
              }
              return msg;
          },
          link: `https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
      },
      ["CONFIG_WHITESPACE" /* CONFIG_WHITESPACE */]: {
              `"preserve". To suppress this warning, provide an explicit value for ` +
              `\`config.compilerOptions.whitespace\`.`
      },
      ["CONFIG_OPTION_MERGE_STRATS" /* CONFIG_OPTION_MERGE_STRATS */]: {
          message: `config.optionMergeStrategies no longer exposes internal strategies. ` +
              `Use custom merge functions instead.`
      },
      ["INSTANCE_SET" /* INSTANCE_SET */]: {
          message: `vm.$set() has been removed as it is no longer needed in Vue 3. ` +
              `Simply use native JavaScript mutations.`
      },
      ["INSTANCE_DELETE" /* INSTANCE_DELETE */]: {
          message: `vm.$delete() has been removed as it is no longer needed in Vue 3. ` +
              `Simply use native JavaScript mutations.`
      },
      ["INSTANCE_DESTROY" /* INSTANCE_DESTROY */]: {
          message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
          link: `https://v3.vuejs.org/api/application-api.html#unmount`
      },
      ["INSTANCE_EVENT_EMITTER" /* INSTANCE_EVENT_EMITTER */]: {
          message: `vm.$on/$once/$off() have been removed. ` +
              `Use an external event emitter library instead.`,
          link: `https://v3.vuejs.org/guide/migration/events-api.html`
      },
      ["INSTANCE_EVENT_HOOKS" /* INSTANCE_EVENT_HOOKS */]: {
          message: event => `"${event}" lifecycle events are no longer supported. From templates, ` +
              `use the "vnode" prefix instead of "hook:". For example, @${event} ` +
              `should be changed to @vnode-${event.slice(5)}. ` +
              `From JavaScript, use Composition API to dynamically register lifecycle ` +
              `hooks.`,
          link: `https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html`
      },
      ["INSTANCE_CHILDREN" /* INSTANCE_CHILDREN */]: {
          message: `vm.$children has been removed. Consider refactoring your logic ` +
              `to avoid relying on direct access to child components.`,
          link: `https://v3.vuejs.org/guide/migration/children.html`
      },
      ["INSTANCE_LISTENERS" /* INSTANCE_LISTENERS */]: {
          message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` +
              `included in vm.$attrs and it is no longer necessary to separately use ` +
              `v-on="$listeners" if you are already using v-bind="$attrs". ` +
              `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,
          link: `https://v3.vuejs.org/guide/migration/listeners-removed.html`
      },
      ["INSTANCE_SCOPED_SLOTS" /* INSTANCE_SCOPED_SLOTS */]: {
          message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
          link: `https://v3.vuejs.org/guide/migration/slots-unification.html`
      },
      ["INSTANCE_ATTRS_CLASS_STYLE" /* INSTANCE_ATTRS_CLASS_STYLE */]: {
          message: componentName => `Component <${componentName ||
            'Anonymous'}> has \`inheritAttrs: false\` but is ` +
              `relying on class/style fallthrough from parent. In Vue 3, class/style ` +
              `are now included in $attrs and will no longer fallthrough when ` +
              `inheritAttrs is false. If you are already using v-bind="$attrs" on ` +
              `component root it should render the same end result. ` +
              `If you are binding $attrs to a non-root element and expecting ` +
              `class/style to fallthrough on root, you will need to now manually bind ` +
              `them on root via :class="$attrs.class".`,
          link: `https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html`
      },
      ["OPTIONS_DATA_FN" /* OPTIONS_DATA_FN */]: {
          message: `The "data" option can no longer be a plain object. ` +
              `Always use a function.`,
          link: `https://v3.vuejs.org/guide/migration/data-option.html`
      },
      ["OPTIONS_DATA_MERGE" /* OPTIONS_DATA_MERGE */]: {
          message: (key) => `Detected conflicting key "${key}" when merging data option values. ` +
              `In Vue 3, data keys are merged shallowly and will override one another.`,
          link: `https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change`
      },
      ["OPTIONS_BEFORE_DESTROY" /* OPTIONS_BEFORE_DESTROY */]: {
          message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
      },
      ["OPTIONS_DESTROYED" /* OPTIONS_DESTROYED */]: {
          message: `\`destroyed\` has been renamed to \`unmounted\`.`
      },
      ["WATCH_ARRAY" /* WATCH_ARRAY */]: {
          message: `"watch" option or vm.$watch on an array value will no longer ` +
              `trigger on array mutation unless the "deep" option is specified. ` +
              `If current usage is intended, you can disable the compat behavior and ` +
              `suppress this warning with:` +
              `\n\n  configureCompat({ ${"WATCH_ARRAY" /* WATCH_ARRAY */}: false })\n`,
          link: `https://v3.vuejs.org/guide/migration/watch.html`
      },
      ["PROPS_DEFAULT_THIS" /* PROPS_DEFAULT_THIS */]: {
          message: (key) => `props default value function no longer has access to "this". The compat ` +
              `build only offers access to this.$options.` +
              `(found in prop "${key}")`,
          link: `https://v3.vuejs.org/guide/migration/props-default-this.html`
      },
      ["CUSTOM_DIR" /* CUSTOM_DIR */]: {
          message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. ` +
              `Use "${newHook}" instead.`,
          link: `https://v3.vuejs.org/guide/migration/custom-directives.html`
      },
      ["V_FOR_REF" /* V_FOR_REF */]: {
          message: `Ref usage on v-for no longer creates array ref values in Vue 3. ` +
              `Consider using function refs or refactor to avoid ref usage altogether.`,
          link: `https://v3.vuejs.org/guide/migration/array-refs.html`
      },
      ["V_ON_KEYCODE_MODIFIER" /* V_ON_KEYCODE_MODIFIER */]: {
          message: `Using keyCode as v-on modifier is no longer supported. ` +
              `Use kebab-case key name modifiers instead.`,
          link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
      },
      ["ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */]: {
          message: (name) => `Attribute "${name}" with v-bind value \`false\` will render ` +
              `${name}="false" instead of removing it in Vue 3. To remove the attribute, ` +
              `use \`null\` or \`undefined\` instead. If the usage is intended, ` +
              `you can disable the compat behavior and suppress this warning with:` +
              `\n\n  configureCompat({ ${"ATTR_FALSE_VALUE" /* ATTR_FALSE_VALUE */}: false })\n`,
          link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
      },
      ["ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */]: {
          message: (name, value, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value}\` will ` +
              `${value === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. ` +
              `Always use explicit "true" or "false" values for enumerated attributes. ` +
              `If the usage is intended, ` +
              `you can disable the compat behavior and suppress this warning with:` +
              `\n\n  configureCompat({ ${"ATTR_ENUMERATED_COERCION" /* ATTR_ENUMERATED_COERCION */}: false })\n`,
          link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
      },
      ["TRANSITION_CLASSES" /* TRANSITION_CLASSES */]: {
          message: `` // this feature cannot be runtime-detected
      },
      ["TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */]: {
          message: `<TransitionGroup> no longer renders a root <span> element by ` +
              `default if no "tag" prop is specified. If you do not rely on the span ` +
              `for styling, you can disable the compat behavior and suppress this ` +
              `warning with:` +
              `\n\n  configureCompat({ ${"TRANSITION_GROUP_ROOT" /* TRANSITION_GROUP_ROOT */}: false })\n`,
          link: `https://v3.vuejs.org/guide/migration/transition-group.html`
      },
      ["COMPONENT_ASYNC" /* COMPONENT_ASYNC */]: {
          message: (comp) => {
              const name = getComponentName(comp);
              return (`Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` ` +
                  `in Vue 3. Plain functions will be treated as functional components in ` +
                  `non-compat build. If you have already migrated all async component ` +
                  `usage and intend to use plain functions for functional components, ` +
                  `you can disable the compat behavior and suppress this ` +
                  `warning with:` +
                  `\n\n  configureCompat({ ${"COMPONENT_ASYNC" /* COMPONENT_ASYNC */}: false })\n`);
          },
          link: `https://v3.vuejs.org/guide/migration/async-components.html`
      },
      ["COMPONENT_FUNCTIONAL" /* COMPONENT_FUNCTIONAL */]: {
          message: (comp) => {
              const name = getComponentName(comp);
              return (`Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" ` +
                  `option has been removed. NOTE: Before migrating to use plain ` +
                  `functions for functional components, first make sure that all async ` +
                  `components usage have been migrated and its compat behavior has ` +
                  `been disabled.`);
          },
          link: `https://v3.vuejs.org/guide/migration/functional-components.html`
      },
      ["COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */]: {
          message: (comp) => {
              const configMsg = `opt-in to ` +
                  `Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL" /* COMPONENT_V_MODEL */}: false }\`.`;
              if (comp.props && isArray(comp.props)
                  ? comp.props.includes('modelValue')
                  : hasOwn(comp.props, 'modelValue')) {
                  return (`Component delcares "modelValue" prop, which is Vue 3 usage, but ` +
                      `is running under Vue 2 compat v-model behavior. You can ${configMsg}`);
              }
              return (`v-model usage on component has changed in Vue 3. Component that expects ` +
                  `to work with v-model should now use the "modelValue" prop and emit the ` +
                  `"update:modelValue" event. You can update the usage and then ${configMsg}`);
          },
          link: `https://v3.vuejs.org/guide/migration/v-model.html`
      },
      ["RENDER_FUNCTION" /* RENDER_FUNCTION */]: {
          message: `Vue 3's render function API has changed.`+`You can opt-in to the new API with:`+`\n\n configureCompat({${"RENDER_FUNCTION"}:false})\n`+`\n(This can also be done per-component via the"compatConfig"option.)`,link:`https:},["FILTERS"]:{message:`filters have been removed in Vue 3.`+`The"|"symbol will be treated as native JavaScript bitwise OR operator.`+`Use method calls or computed properties instead.`,link:`https:},["PRIVATE_APIS"]:{message:name=>`"${name}"is a Vue 2 private API that no longer exists in Vue 3.`+`If you are seeing this warning only due to a dependency,you can`+`suppress this warning via{PRIVATE_APIS:'supress-warning'}.`}};const instanceWarned=Object.create(null);const warnCount=Object.create(null);function warnDeprecation(key,instance,...args){instance=instance||getCurrentInstance();const config=getCompatConfigForKey(key,instance);if(config==='suppress-warning'){return}const dupKey=key+args.join('');let compId=instance&&formatComponentName(instance,instance.type);if(compId==='Anonymous'&&instance){compId=instance.uid}const componentDupKey=dupKey+compId;if(componentDupKey in instanceWarned){return}instanceWarned[componentDupKey]=true;if(dupKey in warnCount){warn(`(deprecation ${key})(${++warnCount[dupKey]+1})`);return}warnCount[dupKey]=0;const{message,link}=deprecationData[key];warn(`(deprecation ${key})${typeof message==='function'?message(...args):message}${link?`\n Details:${link}`:``}`);if(!isCompatEnabled(key,instance,true)){console.error(`^The above deprecation's compat behavior is disabled and will likely ` +
              `lead to runtime errors.`);
      }
  }
  const globalCompatConfig = {
      MODE: 2
  };
  function getCompatConfigForKey(key, instance) {
      const instanceConfig = instance && instance.type.compatConfig;
      if (instanceConfig && key in instanceConfig) {
          return instanceConfig[key];
      }
      return globalCompatConfig[key];
  }
  function isCompatEnabled(key, instance, enableForBuiltIn = false) {
      if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {
          return false;
      }
      const rawMode = getCompatConfigForKey('MODE', instance) || 2;
      const val = getCompatConfigForKey(key, instance);
      const mode = isFunction(rawMode)
          ? rawMode(instance && instance.type)
          : rawMode;
      if (mode === 2) {
          return val !== false;
      }
      else {
          return val === true || val === 'suppress-warning';
      }
  }

  function emit(instance, event, ...rawArgs) {
      const props = instance.vnode.props || EMPTY_OBJ;
      {
          const { emitsOptions, propsOptions: [propsOptions] } = instance;
          if (emitsOptions) {
              if (!(event in emitsOptions) &&
                  !(false )) {
                  if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
                      warn(`Component emitted event "${event}" but it is neither declared in ` +
                          `the emits option nor as an "${toHandlerKey(event)}" prop.`);
                  }
              }
              else {
                  const validator = emitsOptions[event];
                  if (isFunction(validator)) {
                      const isValid = validator(...rawArgs);
                      if (!isValid) {
                          warn(`Invalid event arguments: event validation failed for event "${event}".`);
                      }
                  }
              }
          }
      }
      let args = rawArgs;
      const isModelListener = event.startsWith('update:');
      const modelArg = isModelListener && event.slice(7);
      if (modelArg && modelArg in props) {
          const modifiersKey = `${modelArg === 'modelValue' ? 'model' : modelArg}Modifiers`;
          const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
          if (trim) {
              args = rawArgs.map(a => a.trim());
          }
          else if (number) {
              args = rawArgs.map(toNumber);
          }
      }
      {
          devtoolsComponentEmit(instance, event, args);
      }
      {
          const lowerCaseEvent = event.toLowerCase();
          if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
              warn(`Event "${lowerCaseEvent}" is emitted in component ` +
                  `${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". ` +
                  `Note that HTML attributes are case-insensitive and you cannot use ` +
                  `v-on to listen to camelCase events when using in-DOM templates. ` +
                  `You should probably use "${hyphenate(event)}" instead of "${event}".`);
          }
      }
      let handlerName;
      let handler = props[(handlerName = toHandlerKey(event))] ||
          props[(handlerName = toHandlerKey(camelize(event)))];
      if (!handler && isModelListener) {
          handler = props[(handlerName = toHandlerKey(hyphenate(event)))];
      }
      if (handler) {
          callWithAsyncErrorHandling(handler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
          if (!instance.emitted) {
              instance.emitted = {};
          }
          else if (instance.emitted[handlerName]) {
              return;
          }
          instance.emitted[handlerName] = true;
          callWithAsyncErrorHandling(onceHandler, instance, 6 /* COMPONENT_EVENT_HANDLER */, args);
      }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== undefined) {
          return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction(comp)) {
          const extendEmits = (raw) => {
              const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true);
              if (normalizedFromExtend) {
                  hasExtends = true;
                  extend(normalized, normalizedFromExtend);
              }
          };
          if (!asMixin && appContext.mixins.length) {
              appContext.mixins.forEach(extendEmits);
          }
          if (comp.extends) {
              extendEmits(comp.extends);
          }
          if (comp.mixins) {
              comp.mixins.forEach(extendEmits);
          }
      }
      if (!raw && !hasExtends) {
          cache.set(comp, null);
          return null;
      }
      if (isArray(raw)) {
          raw.forEach(key => (normalized[key] = null));
      }
      else {
          extend(normalized, raw);
      }
      cache.set(comp, normalized);
      return normalized;
  }
 
  function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
          return false;
      }
      key = key.slice(2).replace(/Once$/, '');
      return (hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||
          hasOwn(options, hyphenate(key)) ||
          hasOwn(options, key));
  }

  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = (instance && instance.type.__scopeId) || null;
      return prev;
  }
  function pushScopeId(id) {
      currentScopeId = id;
  }
  
  function popScopeId() {
      currentScopeId = null;
  }
  const withScopeId = (_id) => withCtx;
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot // false only
  ) {
      if (!ctx)
          return fn;
      if (fn._n) {
          return fn;
      }
      const renderFnWithContext = (...args) => {
              `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n` +
              `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
          Object.defineProperty(app.config, 'compilerOptions', {
              get() {
                  warn(msg);
                  return compilerOptions;
              },
              set() {
                  warn(msg);
              }
          });
      }
  }
  function normalizeContainer(container) {
      if (isString(container)) {
          const res = document.querySelector(container);
          if (!res) {
              warn(`Failed to mount app: mount target selector "${container}" returned null.`);
          }
          return res;
      }
      if (container instanceof window.ShadowRoot &&
          container.mode === 'closed') {
          warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
      }
      return container;
  }

  function initDev() {
      {
          {
              console.info(`You are running a development build of Vue.\n` +
                  `Make sure to use the production build (*.prod.js) when deploying for production.`);
          }
          initCustomFormatter();
      }
  }

  function defaultOnError(error) {
      throw error;
  }
  function defaultOnWarn(msg) {
      console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
      const msg = (messages || errorMessages)[code] + (additionalMessage || ``)
          ;
      const error = new SyntaxError(String(msg));
      error.code = code;
      error.loc = loc;
      return error;
  }
  const errorMessages = {
      // parse errors
      [0 /* ABRUPT_CLOSING_OF_EMPTY_COMMENT */]: 'Illegal comment.',
      [1 /* CDATA_IN_HTML_CONTENT */]: 'CDATA section is allowed only in XML context.',
      [2 /* DUPLICATE_ATTRIBUTE */]: 'Duplicate attribute.',
      [3 /* END_TAG_WITH_ATTRIBUTES */]: 'End tag cannot have attributes.',
      [4 /* END_TAG_WITH_TRAILING_SOLIDUS */]: "Illegal '/' in tags.",
      [5 /* EOF_BEFORE_TAG_NAME */]: 'Unexpected EOF in tag.',
      [6 /* EOF_IN_CDATA */]: 'Unexpected EOF in CDATA section.',
      [7 /* EOF_IN_COMMENT */]: 'Unexpected EOF in comment.',
      [8 /* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */]: 'Unexpected EOF in script.',
      [9 /* EOF_IN_TAG */]: 'Unexpected EOF in tag.',
      [10 /* INCORRECTLY_CLOSED_COMMENT */]: 'Incorrectly closed comment.',
      [11 /* INCORRECTLY_OPENED_COMMENT */]: 'Incorrectly opened comment.',
      [12 /* INVALID_FIRST_CHARACTER_OF_TAG_NAME */]: "Illegal tag name. Use '&lt;' to print '<'.",
      [13 /* MISSING_ATTRIBUTE_VALUE */]: 'Attribute value was expected.',
      [14 /* MISSING_END_TAG_NAME */]: 'End tag name was expected.',
      [15 /* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */]: 'Whitespace was expected.',
      [16 /* NESTED_COMMENT */]: "Unexpected '<!--' in comment.",
      [17 /* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */]: 'Attribute name cannot contain U+0022("), U+0027 (\'), and U+003C (<).',
      [18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */]: 'Unquoted attribute value cannot contain U+0022 ("),U+0027(\'), U+003C (<), U+003D (=), and U+0060 (`).',[19]:"Attribute name cannot start with '='.",[21]:"'<?' is allowed only in XML context.",[20]:`Unexpected null cahracter.`,[22]:"Illegal '/' in tags.",[23]:'Invalid end tag.',[24]:'Element is missing end tag.',[25]:'Interpolation end sign was not found.',[26]:'End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.',[27]:`v-if/v-else-if is missing expression.`,[28]:`v-if/else branches must use unique keys.`,[29]:`v-else/v-else-if has no adjacent v-if.`,[30]:`v-for is missing expression.`,[31]:`v-for has invalid expression.`,[32]:`<template v-for>key should be placed on the<template>tag.`,[33]:`v-bind is missing expression.`,[34]:`v-on is missing expression.`,[35]:`Unexpected custom directive on<slot>outlet.`,[36]:`Mixed v-slot usage on both the component and nested<template>.`+`When there are multiple named slots,all slots should use<template>`+`syntax to avoid scope ambiguity.`,[37]:`Duplicate slot names found.`,[38]:`Extraneous children found when component already has explicitly named`+`default slot.These children will be ignored.`,[39]:`v-slot can only be used on components or<template>tags.`,[40]:`v-model is missing expression.`,[41]:`v-model value must be a valid JavaScript member expression.`,[42]:`v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,[43]:`Error parsing JavaScript expression:`,[44]:`<KeepAlive>expects exactly one child component.`,[45]:`"prefixIdentifiers"option is not supported in this build of compiler.`,[46]:`ES module mode is not supported in this build of compiler.`,[47]:`"cacheHandlers"option is only supported when the"prefixIdentifiers"option is enabled.`,[48]:`"scopeId"option is only supported in module mode.`,[49]:``};const FRAGMENT=Symbol(`Fragment`);const TELEPORT=Symbol(`Teleport`);const SUSPENSE=Symbol(`Suspense`);const KEEP_ALIVE=Symbol(`KeepAlive`);const BASE_TRANSITION=Symbol(`BaseTransition`);const OPEN_BLOCK=Symbol(`openBlock`);const CREATE_BLOCK=Symbol(`createBlock`);const CREATE_VNODE=Symbol(`createVNode`);const CREATE_COMMENT=Symbol(`createCommentVNode`);const CREATE_TEXT=Symbol(`createTextVNode`);const CREATE_STATIC=Symbol(`createStaticVNode`);const RESOLVE_COMPONENT=Symbol(`resolveComponent`);const RESOLVE_DYNAMIC_COMPONENT=Symbol(`resolveDynamicComponent`);const RESOLVE_DIRECTIVE=Symbol(`resolveDirective`);const RESOLVE_FILTER=Symbol(`resolveFilter`);const WITH_DIRECTIVES=Symbol(`withDirectives`);const RENDER_LIST=Symbol(`renderList`);const RENDER_SLOT=Symbol(`renderSlot`);const CREATE_SLOTS=Symbol(`createSlots`);const TO_DISPLAY_STRING=Symbol(`toDisplayString`);const MERGE_PROPS=Symbol(`mergeProps`);const TO_HANDLERS=Symbol(`toHandlers`);const CAMELIZE=Symbol(`camelize`);const CAPITALIZE=Symbol(`capitalize`);const TO_HANDLER_KEY=Symbol(`toHandlerKey`);const SET_BLOCK_TRACKING=Symbol(`setBlockTracking`);const PUSH_SCOPE_ID=Symbol(`pushScopeId`);const POP_SCOPE_ID=Symbol(`popScopeId`);const WITH_SCOPE_ID=Symbol(`withScopeId`);const WITH_CTX=Symbol(`withCtx`);const UNREF=Symbol(`unref`);const IS_REF=Symbol(`isRef`);const helperNameMap={[FRAGMENT]:`Fragment`,[TELEPORT]:`Teleport`,[SUSPENSE]:`Suspense`,[KEEP_ALIVE]:`KeepAlive`,[BASE_TRANSITION]:`BaseTransition`,[OPEN_BLOCK]:`openBlock`,[CREATE_BLOCK]:`createBlock`,[CREATE_VNODE]:`createVNode`,[CREATE_COMMENT]:`createCommentVNode`,[CREATE_TEXT]:`createTextVNode`,[CREATE_STATIC]:`createStaticVNode`,[RESOLVE_COMPONENT]:`resolveComponent`,[RESOLVE_DYNAMIC_COMPONENT]:`resolveDynamicComponent`,[RESOLVE_DIRECTIVE]:`resolveDirective`,[RESOLVE_FILTER]:`resolveFilter`,[WITH_DIRECTIVES]:`withDirectives`,[RENDER_LIST]:`renderList`,[RENDER_SLOT]:`renderSlot`,[CREATE_SLOTS]:`createSlots`,[TO_DISPLAY_STRING]:`toDisplayString`,[MERGE_PROPS]:`mergeProps`,[TO_HANDLERS]:`toHandlers`,[CAMELIZE]:`camelize`,[CAPITALIZE]:`capitalize`,[TO_HANDLER_KEY]:`toHandlerKey`,[SET_BLOCK_TRACKING]:`setBlockTracking`,[PUSH_SCOPE_ID]:`pushScopeId`,[POP_SCOPE_ID]:`popScopeId`,[WITH_SCOPE_ID]:`withScopeId`,[WITH_CTX]:`withCtx`,[UNREF]:`unref`,[IS_REF]:`isRef`};function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(s=>{helperNameMap[s]=helpers[s]})}const locStub={source:'',start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function createRoot(children,loc=locStub){return{type:0,children,helpers:[],components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:undefined,loc}}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives,isBlock=false,disableTracking=false,loc=locStub){if(context){if(isBlock){context.helper(OPEN_BLOCK);context.helper(CREATE_BLOCK)}else{context.helper(CREATE_VNODE)}if(directives){context.helper(WITH_DIRECTIVES)}}return{type:13,tag,props,children,patchFlag,dynamicProps,directives,isBlock,disableTracking,loc}}function createArrayExpression(elements,loc=locStub){return{type:17,loc,elements}}function createObjectExpression(properties,loc=locStub){return{type:15,loc,properties}}function createObjectProperty(key,value){return{type:16,loc:locStub,key:isString(key)?createSimpleExpression(key,true):key,value}}function createSimpleExpression(content,isStatic,loc=locStub,constType=0){return{type:4,loc,content,isStatic,constType:isStatic?3:constType}}function createCompoundExpression(children,loc=locStub){return{type:8,loc,children}}function createCallExpression(callee,args=[],loc=locStub){return{type:14,loc,callee,arguments:args}}function createFunctionExpression(params,returns=undefined,newline=false,isSlot=false,loc=locStub){return{type:18,params,returns,newline,isSlot,loc}}function createConditionalExpression(test,consequent,alternate,newline=true){return{type:19,test,consequent,alternate,newline,loc:locStub}}function createCacheExpression(index,value,isVNode=false){return{type:20,index,value,isVNode,loc:locStub}}const isStaticExp=(p)=>p.type===4&&p.isStatic;const isBuiltInType=(tag,expected)=>tag===expected||tag===hyphenate(expected);function isCoreComponent(tag){if(isBuiltInType(tag,'Teleport')){return TELEPORT}else if(isBuiltInType(tag,'Suspense')){return SUSPENSE}else if(isBuiltInType(tag,'KeepAlive')){return KEEP_ALIVE}else if(isBuiltInType(tag,'BaseTransition')){return BASE_TRANSITION}}const nonIdentifierRE=/^\d|[^\$\w]/;const isSimpleIdentifier=(name)=>!nonIdentifierRE.test(name);const validFirstIdentCharRE=/[A-Za-z_$\xA0-\uFFFF]/;const validIdentCharRE=/[\.\w$\xA0-\uFFFF]/;const whitespaceRE=/\s+[.[]\s*|\s*[.[]\s+/g;const isMemberExpression=(path)=>{path=path.trim().replace(whitespaceRE,s=>s.trim());let state=0;let prevState=0;let currentOpenBracketCount=0;let currentStringType=null;for(let i=0;i<path.length;i++){const char=path.charAt(i);switch(state){case 0:if(char==='['){prevState=state;state=1;currentOpenBracketCount++}else if(!(i===0?validFirstIdentCharRE:validIdentCharRE).test(char)){return false}break;case 1:if(char===`'` || char === `"` || char === '`') {
                      prevState = state;
                      state = 2 /* inString */;
                      currentStringType = char;
                  }
                  else if (char === `[`) {
                      currentOpenBracketCount++;
                  }
                  else if (char === `]`) {
                      if (!--currentOpenBracketCount) {
                          state = prevState;
                      }
                  }
                  break;
              case 2 /* inString */:
                  if (char === currentStringType) {
                      state = prevState;
                      currentStringType = null;
                  }
                  break;
          }
      }
      return !currentOpenBracketCount;
  };
  function getInnerRange(loc, offset, length) {
      const source = loc.source.substr(offset, length);
      const newLoc = {
          source,
          start: advancePositionWithClone(loc.start, loc.source, offset),
          end: loc.end
      };
      if (length != null) {
          newLoc.end = advancePositionWithClone(loc.start, loc.source, offset + length);
      }
      return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
      return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
      let linesCount = 0;
      let lastNewLinePos = -1;
      for (let i = 0; i < numberOfCharacters; i++) {
          if (source.charCodeAt(i) === 10 /* newline char code */) {
              linesCount++;
              lastNewLinePos = i;
          }
      }
      pos.offset += numberOfCharacters;
      pos.line += linesCount;
      pos.column =
          lastNewLinePos === -1
              ? pos.column + numberOfCharacters
              : numberOfCharacters - lastNewLinePos;
      return pos;
  }
  function assert(condition, msg) {
      if (!condition) {
          throw new Error(msg || `unexpected compiler condition`);
      }
  }
  function findDir(node, name, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 7 /* DIRECTIVE */ &&
              (allowEmpty || p.exp) &&
              (isString(name) ? p.name === name : name.test(p.name))) {
              return p;
          }
      }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
      for (let i = 0; i < node.props.length; i++) {
          const p = node.props[i];
          if (p.type === 6 /* ATTRIBUTE */) {
              if (dynamicOnly)
                  continue;
              if (p.name === name && (p.value || allowEmpty)) {
                  return p;
              }
          }
          else if (p.name === 'bind' &&
              (p.exp || allowEmpty) &&
              isBindKey(p.arg, name)) {
              return p;
          }
      }
  }
  function isBindKey(arg, name) {
      return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
      return node.props.some(p => p.type === 7 /* DIRECTIVE */ &&
          p.name === 'bind' &&
          (!p.arg || // v-bind="obj"
              p.arg.type !== 4 /* SIMPLE_EXPRESSION */ || // v-bind:[_ctx.foo]
              !p.arg.isStatic) // v-bind:[foo]
      );
  }
  function isText(node) {
      return node.type === 5 /* INTERPOLATION */ || node.type === 2 /* TEXT */;
  }
  function isVSlot(p) {
      return p.type === 7 /* DIRECTIVE */ && p.name === 'slot';
  }
  function isTemplateNode(node) {
      return (node.type === 1 /* ELEMENT */ && node.tagType === 3 /* TEMPLATE */);
  }
  function isSlotOutlet(node) {
      return node.type === 1 /* ELEMENT */ && node.tagType === 2 /* SLOT */;
  }
  function injectProp(node, prop, context) {
      let propsWithInjection;
      const props = node.type === 13 /* VNODE_CALL */ ? node.props : node.arguments[2];
      if (props == null || isString(props)) {
          propsWithInjection = createObjectExpression([prop]);
      }
      else if (props.type === 14 /* JS_CALL_EXPRESSION */) {
      if (isQuoted) {
          advanceBy(context, 1);
          const endIndex = context.source.indexOf(quote);
          if (endIndex === -1) {
              content = parseTextData(context, context.source.length, 4 /* ATTRIBUTE_VALUE */);
          }
          else {
              content = parseTextData(context, endIndex, 4 /* ATTRIBUTE_VALUE */);
              advanceBy(context, 1);
          }
      }
      else {
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          if (!match) {
              return undefined;
          }
          const unexpectedChars = /["'<=`]/g;
          let m;
          while ((m = unexpectedChars.exec(match[0]))) {
              emitError(context, 18 /* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */, m.index);
          }
          content = parseTextData(context, match[0].length, 4 /* ATTRIBUTE_VALUE */);
      }
      return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
      const [open, close] = context.options.delimiters;
      const closeIndex = context.source.indexOf(close, open.length);
      if (closeIndex === -1) {
          emitError(context, 25 /* X_MISSING_INTERPOLATION_END */);
          return undefined;
      }
      const start = getCursor(context);
      advanceBy(context, open.length);
      const innerStart = getCursor(context);
      const innerEnd = getCursor(context);
      const rawContentLength = closeIndex - open.length;
      const rawContent = context.source.slice(0, rawContentLength);
      const preTrimContent = parseTextData(context, rawContentLength, mode);
      const content = preTrimContent.trim();
      const startOffset = preTrimContent.indexOf(content);
      if (startOffset > 0) {
          advancePositionWithMutation(innerStart, rawContent, startOffset);
      }
      const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
      advancePositionWithMutation(innerEnd, rawContent, endOffset);
      advanceBy(context, close.length);
      return {
          type: 5 /* INTERPOLATION */,
          content: {
              type: 4 /* SIMPLE_EXPRESSION */,
              isStatic: false,
              constType: 0 /* NOT_CONSTANT */,
              content,
              loc: getSelection(context, innerStart, innerEnd)
          },
          loc: getSelection(context, start)
      };
  }
  function parseText(context, mode) {
      const endTokens = ['<', context.options.delimiters[0]];
      if (mode === 3 /* CDATA */) {
          endTokens.push(']]>');
      }
      let endIndex = context.source.length;
      for (let i = 0; i < endTokens.length; i++) {
          const index = context.source.indexOf(endTokens[i], 1);
          if (index !== -1 && endIndex > index) {
              endIndex = index;
          }
      }
      const start = getCursor(context);
      const content = parseTextData(context, endIndex, mode);
      return {
          type: 2 /* TEXT */,
          content,
          loc: getSelection(context, start)
      };
  }
  function parseTextData(context, length, mode) {
      const rawText = context.source.slice(0, length);
      advanceBy(context, length);
      if (mode === 2 /* RAWTEXT */ ||
          mode === 3 /* CDATA */ ||
          rawText.indexOf('&') === -1) {
          return rawText;
      }
      else {
          return context.options.decodeEntities(rawText, mode === 4 /* ATTRIBUTE_VALUE */);
      }
  }
  function getCursor(context) {
      const { column, line, offset } = context;
      return { column, line, offset };
  }
  function getSelection(context, start, end) {
      end = end || getCursor(context);
      return {
          start,
          end,
          source: context.originalSource.slice(start.offset, end.offset)
      };
  }
  function last(xs) {
      return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
      return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
      const { source } = context;
      advancePositionWithMutation(context, source, numberOfCharacters);
      context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
      const match = /^[\t\r\n\f ]+/.exec(context.source);
      if (match) {
          advanceBy(context, match[0].length);
      }
  }
  function getNewPosition(context, start, numberOfCharacters) {
      return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset, loc = getCursor(context)) {
      if (offset) {
          loc.offset += offset;
          loc.column += offset;
      }
      context.options.onError(createCompilerError(code, {
          start: loc,
          end: loc,
          source: ''
      }));
  }
  function isEnd(context, mode, ancestors) {
      const s = context.source;
      switch (mode) {
          case 0 /* DATA */:
              if (startsWith(s, '</')) {
                  // TODO: probably bad performance
                  for (let i = ancestors.length - 1; i >= 0; --i) {
                      if (startsWithEndTagOpen(s, ancestors[i].tag)) {
                          return true;
                      }
                  }
              }
              break;
          case 1 /* RCDATA */:
          case 2 /* RAWTEXT */: {
              const parent = last(ancestors);
              if (parent && startsWithEndTagOpen(s, parent.tag)) {
                  return true;
              }
              break;
          }
          case 3 /* CDATA */:
              if (startsWith(s, ']]>')) {
                  return true;
              }
              break;
      }
      return !s;
  }
  function startsWithEndTagOpen(source, tag) {
      return (startsWith(source, '</') &&
          source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() &&
          /[\t\r\n\f />]/.test(source[2 + tag.length] || '>'));
  }

  function hoistStatic(root, context) {
      walk(root, context, 
      isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
      const { children } = root;
      return (children.length === 1 &&
          child.type === 1 /* ELEMENT */ &&
          !isSlotOutlet(child));
  }
  function walk(node, context, doNotHoistNode = false) {
      let hasHoistedNode = false;
      let canStringify = true;
      const { children } = node;
      for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.type === 1 /* ELEMENT */ &&
              child.tagType === 0 /* ELEMENT */) {
              const constantType = doNotHoistNode
                  ? 0 /* NOT_CONSTANT */
                  : getConstantType(child, context);
              if (constantType > 0 /* NOT_CONSTANT */) {
                  if (constantType < 3 /* CAN_STRINGIFY */) {
                      canStringify = false;
                  }
                  if (constantType >= 2 /* CAN_HOIST */) {
                      child.codegenNode.patchFlag =
                          -1 /* HOISTED */ + (` /* HOISTED */` );
                      child.codegenNode = context.hoist(child.codegenNode);
                      hasHoistedNode = true;
                      continue;
                  }
              }
              else {
                  const codegenNode = child.codegenNode;
                  if (codegenNode.type === 13 /* VNODE_CALL */) {
                      const flag = getPatchFlag(codegenNode);
                      if ((!flag ||
                          flag === 512 /* NEED_PATCH */ ||
                          flag === 1 /* TEXT */) &&
                          getGeneratedPropsConstantType(child, context) >=
                              2 /* CAN_HOIST */) {
                          const props = getNodeProps(child);
                          if (props) {
                              codegenNode.props = context.hoist(props);
                          }
                      }
                  }
              }
          }
          else if (child.type === 12 /* TEXT_CALL */) {
              const contentType = getConstantType(child.content, context);
              if (contentType > 0) {
                  if (contentType < 3 /* CAN_STRINGIFY */) {
                      canStringify = false;
                  }
                  if (contentType >= 2 /* CAN_HOIST */) {
                      child.codegenNode = context.hoist(child.codegenNode);
                      hasHoistedNode = true;
                  }
              }
          }
          if (child.type === 1 /* ELEMENT */) {
              const isComponent = child.tagType === 1 /* COMPONENT */;
              if (isComponent) {
                  context.scopes.vSlot++;
              }
              walk(child, context);
              if (isComponent) {
                  context.scopes.vSlot--;
              }
          }
          else if (child.type === 11 /* FOR */) {
              walk(child, context, child.children.length === 1);
          }
          else if (child.type === 9 /* IF */) {
              for (let i = 0; i < child.branches.length; i++) {
                  walk(child.branches[i], context, child.branches[i].children.length === 1);
              }
          }
      }
      if (canStringify && hasHoistedNode && context.transformHoist) {
          context.transformHoist(children, context, node);
      }
  }
  function getConstantType(node, context) {
      const { constantCache } = context;
      switch (node.type) {
          case 1 /* ELEMENT */:
              if (node.tagType !== 0 /* ELEMENT */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const cached = constantCache.get(node);
              if (cached !== undefined) {
                  return cached;
              }
              const codegenNode = node.codegenNode;
              if (codegenNode.type !== 13 /* VNODE_CALL */) {
                  return 0 /* NOT_CONSTANT */;
              }
              const flag = getPatchFlag(codegenNode);
              if (!flag) {
                  let returnType = 3 /* CAN_STRINGIFY */;
          return decoder.children[0].getAttribute('foo');
      }
      else {
          decoder.innerHTML = raw;
          return decoder.textContent;
      }
  }

  const isRawTextContainer = /*#__PURE__*/ makeMap('style,iframe,script,noscript', true);
  const parserOptions = {
      isVoidTag,
      isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),
      isPreTag: tag => tag === 'pre',
      decodeEntities: decodeHtmlBrowser ,
      isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
              return TRANSITION$1;
          }
          else if (isBuiltInType(tag, `TransitionGroup`)) {
              return TRANSITION_GROUP;
          }
      },
      getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0 /* HTML */;
          if (parent && ns === 2 /* MATH_ML */) {
              if (parent.tag === 'annotation-xml') {
                  if (tag === 'svg') {
                      return 1 /* SVG */;
                  }
                  if (parent.props.some(a => a.type === 6 /* ATTRIBUTE */ &&
                      a.name === 'encoding' &&
                      a.value != null &&
                      (a.value.content === 'text/html' ||
                          a.value.content === 'application/xhtml+xml'))) {
                      ns = 0 /* HTML */;
                  }
              }
              else if (/^m(?:[ions]|text)$/.test(parent.tag) &&
                  tag !== 'mglyph' &&
                  tag !== 'malignmark') {
                  ns = 0 /* HTML */;
              }
          }
          else if (parent && ns === 1 /* SVG */) {
              if (parent.tag === 'foreignObject' ||
                  parent.tag === 'desc' ||
                  parent.tag === 'title') {
                  ns = 0 /* HTML */;
              }
          }
          if (ns === 0 /* HTML */) {
              if (tag === 'svg') {
                  return 1 /* SVG */;
              }
              if (tag === 'math') {
                  return 2 /* MATH_ML */;
              }
          }
          return ns;
      },
      getTextMode({ tag, ns }) {
          if (ns === 0 /* HTML */) {
              if (tag === 'textarea' || tag === 'title') {
                  return 1 /* RCDATA */;
              }
              if (isRawTextContainer(tag)) {
                  return 2 /* RAWTEXT */;
              }
          }
          return 0 /* DATA */;
      }
  };

  const transformStyle = node => {
      if (node.type === 1 /* ELEMENT */) {
          node.props.forEach((p, i) => {
              if (p.type === 6 /* ATTRIBUTE */ && p.name === 'style' && p.value) {
                  node.props[i] = {
                      type: 7 /* DIRECTIVE */,
                      name: `bind`,
                      arg: createSimpleExpression(`style`, true, p.loc),
                      exp: parseInlineCSS(p.value.content, p.loc),
                      modifiers: [],
                      loc: p.loc
                  };
              }
          });
      }
  };
  const parseInlineCSS = (cssText, loc) => {
      const normalized = parseStringStyle(cssText);
      return createSimpleExpression(JSON.stringify(normalized), false, loc, 3 /* CAN_STRINGIFY */);
  };

  function createDOMCompilerError(code, loc) {
      return createCompilerError(code, loc, DOMErrorMessages );
  }
  const DOMErrorMessages = {
      [49 /* X_V_HTML_NO_EXPRESSION */]: `v-html is missing expression.`,
      [50 /* X_V_HTML_WITH_CHILDREN */]: `v-html will override element children.`,
      [51 /* X_V_TEXT_NO_EXPRESSION */]: `v-text is missing expression.`,
      [52 /* X_V_TEXT_WITH_CHILDREN */]: `v-text will override element children.`,
      [53 /* X_V_MODEL_ON_INVALID_ELEMENT */]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
      [54 /* X_V_MODEL_ARG_ON_ELEMENT */]: `v-model argument is not supported on plain elements.`,
      [55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
      [56 /* X_V_MODEL_UNNECESSARY_VALUE */]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
      [57 /* X_V_SHOW_NO_EXPRESSION */]: `v-show is missing expression.`,
      [58 /* X_TRANSITION_INVALID_CHILDREN */]: `<Transition> expects exactly one child element or component.`,
      [59 /* X_IGNORED_SIDE_EFFECT_TAG */]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
  };

  const transformVHtml = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(49 /* X_V_HTML_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(50 /* X_V_HTML_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression('', true))
          ]
      };
  };

  const transformVText = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(51 /* X_V_TEXT_NO_EXPRESSION */, loc));
      }
      if (node.children.length) {
          context.onError(createDOMCompilerError(52 /* X_V_TEXT_WITH_CHILDREN */, loc));
          node.children.length = 0;
      }
      return {
          props: [
              createObjectProperty(createSimpleExpression(`textContent`, true), exp
                  ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc)
                  : createSimpleExpression('', true))
          ]
      };
  };

  const transformModel$1 = (dir, node, context) => {
      const baseResult = transformModel(dir, node, context);
      if (!baseResult.props.length || node.tagType === 1 /* COMPONENT */) {
          return baseResult;
      }
      if (dir.arg) {
          context.onError(createDOMCompilerError(54 /* X_V_MODEL_ARG_ON_ELEMENT */, dir.arg.loc));
      }
      function checkDuplicatedValue() {
          const value = findProp(node, 'value');
          if (value) {
              context.onError(createDOMCompilerError(56 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));
          }
      }
      const { tag } = node;
      const isCustomElement = context.isCustomElement(tag);
      if (tag === 'input' ||
          tag === 'textarea' ||
          tag === 'select' ||
          isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === 'input' || isCustomElement) {
              const type = findProp(node, `type`);
              if (type) {
                  if (type.type === 7 /* DIRECTIVE */) {
                      // :type="foo"
                      directiveToUse = V_MODEL_DYNAMIC;
                  }
                  else if (type.value) {
                      switch (type.value.content) {
                          case 'radio':
                              directiveToUse = V_MODEL_RADIO;
                              break;
                          case 'checkbox':
                              directiveToUse = V_MODEL_CHECKBOX;
                              break;
                          case 'file':
                              isInvalidType = true;
                              context.onError(createDOMCompilerError(55 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));
                              break;
                          default:
                              checkDuplicatedValue();
                              break;
                      }
                  }
              }
              else if (hasDynamicKeyVBind(node)) {
                  directiveToUse = V_MODEL_DYNAMIC;
              }
              else {
                  checkDuplicatedValue();
              }
          }
          else if (tag === 'select') {
              directiveToUse = V_MODEL_SELECT;
          }
          else {
              checkDuplicatedValue();
          }
          if (!isInvalidType) {
              baseResult.needRuntime = context.helper(directiveToUse);
          }
      }
      else {
          context.onError(createDOMCompilerError(53 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));
      }
      baseResult.props = baseResult.props.filter(p => !(p.key.type === 4 /* SIMPLE_EXPRESSION */ &&
          p.key.content === 'modelValue'));
      return baseResult;
  };

  const isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`);
  const isNonKeyModifier = /*#__PURE__*/ makeMap(
`stop,prevent,self,`   +
      `ctrl,shift,alt,meta,exact,` +
      `middle`);
  const maybeKeyModifier = /*#__PURE__*/ makeMap('left,right');
  const isKeyboardEvent = /*#__PURE__*/ makeMap(`onkeyup,onkeydown,onkeypress`, true);
  const resolveModifiers = (key, modifiers, context, loc) => {
      const keyModifiers = [];
      const nonKeyModifiers = [];
      const eventOptionModifiers = [];
      for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (isEventOptionModifier(modifier)) {
              // eventOptionModifiers: modifiers for addEventListener() options,
              // e.g. .passive & .capture
              eventOptionModifiers.push(modifier);
          }
          else {
              // runtimeModifiers: modifiers that needs runtime guards
              if (maybeKeyModifier(modifier)) {
                  if (isStaticExp(key)) {
                      if (isKeyboardEvent(key.content)) {
                          keyModifiers.push(modifier);
                      }
                      else {
                          nonKeyModifiers.push(modifier);
                      }
                  }
                  else {
                      keyModifiers.push(modifier);
                      nonKeyModifiers.push(modifier);
                  }
              }
              else {
                  if (isNonKeyModifier(modifier)) {
                      nonKeyModifiers.push(modifier);
                  }
                  else {
                      keyModifiers.push(modifier);
                  }
              }
          }
      }
      return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
      };
  };
  const transformClick = (key, event) => {
      const isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';
      return isStaticClick
          ? createSimpleExpression(event, true)
          : key.type !== 4 /* SIMPLE_EXPRESSION */
              ? createCompoundExpression([
                  `(`,
                  key,
                  `) === "onClick" ? "${event}" : (`,
                  key,
                  `)`
              ])
              : key;
  };
  const transformOn$1 = (dir, node, context) => {
      return transformOn(dir, node, context, baseResult => {
          const { modifiers } = dir;
          if (!modifiers.length)
              return baseResult;
          let { key, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key, modifiers, context, dir.loc);
          // normalize click.right and click.middle since they don't actually fire
          if (nonKeyModifiers.includes('right')) {
              key = transformClick(key, `onContextmenu`);
          }
          if (nonKeyModifiers.includes('middle')) {
              key = transformClick(key, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
                  handlerExp,
                  JSON.stringify(nonKeyModifiers)
              ]);
          }
          if (keyModifiers.length &&
              // if event name is dynamic, always wrap with keys guard
              (!isStaticExp(key) || isKeyboardEvent(key.content))) {
              handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
                  handlerExp,
                  JSON.stringify(keyModifiers)
              ]);
          }
          if (eventOptionModifiers.length) {
              const modifierPostfix = eventOptionModifiers.map(capitalize).join('');
              key = isStaticExp(key)
                  ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)
                  : createCompoundExpression([`(`, key, `) + "${modifierPostfix}"`]);
          }
          return {
              props: [createObjectProperty(key, handlerExp)]
          };
      });
  };

  const transformShow = (dir, node, context) => {
      const { exp, loc } = dir;
      if (!exp) {
          context.onError(createDOMCompilerError(57 /* X_V_SHOW_NO_EXPRESSION */, loc));
      }
      return {
          props: [],
          needRuntime: context.helper(V_SHOW)
      };
  };

  const warnTransitionChildren = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 1 /* COMPONENT */) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION$1) {
              return () => {
                  if (node.children.length && hasMultipleChildren(node)) {
                      context.onError(createDOMCompilerError(58 /* X_TRANSITION_INVALID_CHILDREN */, {
                          start: node.children[0].loc.start,
                          end: node.children[node.children.length - 1].loc.end,
                          source: ''
                      }));
                  }
              };
          }
      }
  };
  function hasMultipleChildren(node) {
      const children = (node.children = node.children.filter(c => c.type !== 3 /* COMMENT */));
      const child = children[0];
      return (children.length !== 1 ||
          child.type === 11 /* FOR */ ||
          (child.type === 9 /* IF */ && child.branches.some(hasMultipleChildren)));
  }

  const ignoreSideEffectTags = (node, context) => {
      if (node.type === 1 /* ELEMENT */ &&
          node.tagType === 0 /* ELEMENT */ &&
          (node.tag === 'script' || node.tag === 'style')) {
          context.onError(createDOMCompilerError(59 /* X_IGNORED_SIDE_EFFECT_TAG */, node.loc));
          context.removeNode();
      }
  };

  const DOMNodeTransforms = [
      transformStyle,
      ...([warnTransitionChildren] )
  ];
  const DOMDirectiveTransforms = {
      cloak: noopDirectiveTransform,
      html: transformVHtml,
      text: transformVText,
      model: transformModel$1,
      on: transformOn$1,
      show: transformShow
  };
  function compile$1(template, options = {}) {
      return baseCompile(template, extend({}, parserOptions, options, {
          nodeTransforms: [
              ignoreSideEffectTags,
              ...DOMNodeTransforms,
              ...(options.nodeTransforms || [])
          ],
          directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
          transformHoist: null 
      }));
  }

