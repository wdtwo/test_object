<html>
<head>
  <title></title>
  <script src="three.js"></script>
  <style type="text/css">
      * {
          margin:0;
          padding:0;
      }
      .flex{
          display: flex;
          flex-direction: row;
          justify-content: center;
          align-items: center;
      }
  </style>
</head>
<body>
    <div class="flex">
        <div class="mask-five-content" id="container" style="background-color: #eaeaea;"></div>
    </div>
    
      
<script>
    var SCREEN_WIDTH  = null; //盒子宽
    var SCREEN_HEIGHT = null; //盒子高
    var scene         = null; //场景
    var mesh          = null;
    var camera        = null;
    var renderer      = null;
    var container     = document.getElementById('container')
    var me            = false;
    var mouse         = new THREE.Vector2;
    var pos           = { x: 0, y: 0};
    var rotation      = { x: 0, y: 0};
    var target        = {x: 2.1 * Math.PI,y: Math.PI / 4.5};
    var p             = {x: 0,y: 0};
    var de = false;
    var type = "";
    var node = "";
  
    var step = 0;
      
    var viewX = 0;
    var x = 1e3;
    var j = 1e3;
    var PI_HALF = Math.PI / 2;
  
    var isStop = false;
  
    var t = new THREE.SphereGeometry(3, 20, 20);
    var multiply = new THREE.MeshBasicMaterial({
      color: '#DF5943'
    });
  
    //网页加载完毕后会被调用
    function init() {
        SCREEN_WIDTH  = 500;
        SCREEN_HEIGHT = 500;
        //创建一个场景（场景是一个容器，用于保存、跟踪所要渲染的物体和使用的光源）
        scene = new THREE.Scene();
    
        //创建一个摄像机对象
        camera = new THREE.PerspectiveCamera(30, 1, 1, 1000);
        camera.position.x = 30;
        camera.position.y = 30;
        camera.position.z = 30;
        camera.lookAt(new THREE.Vector3(80, 80, 80));
    
        scene.add(new THREE.AmbientLight('#DF5943'));//添加光源
    
        //创建一个WebGL渲染器并设置其大小
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        // renderer.setClearColor(new THREE.Color(0x00000)); //0xc0c0c0
        // renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
    
        //将渲染的结果输出到指定页面元素中
        // document.getElementById("WebGL-output").appendChild(renderer.domElement);
        container.appendChild(renderer.domElement);
        container.addEventListener("mousedown", onMouseDown, false);
        // container.addEventListener("touchstart", start, false);
        // container.addEventListener("mouseenter", scroll, false);
        container.addEventListener("mouseleave", onMouseOut, false);
        container.addEventListener("mousemove", onMouseMove, false);
        // window.addEventListener("click", check, false);
        // container.addEventListener("touchend", onMouseWheel, false);
        container.addEventListener("touchmove", move, false);
        // window.addEventListener("resize", resize, false);
    
        drawGlobe()
        var pos = [ [ 132, 122 ], [ 20, 130 ], [ 13, 156.5 ], [ 24.5, 179 ], [ -24, -77 ], [ 57.5, -149 ], [ 36.1, -6.41 ], [ 25, -25 ], [ -38, 89.5 ], [ 38, 94 ], [ -32, -56 ], [ 5, -52 ], [ 10, -41.6 ] ];
        let a = 138.68;
        addLogo(-138.68, 38.68, 139, -10, -40, -0);
        drawCircle(-.494 * a, a, .914 * a, -50, -20, "Beijing");
        parseNode(-.494 * a, a, .914 * a, -50, -20, "Beijing");
        a = 138.78;
        //create(-.480 * a, a, .914 * a, -50, -20, "Beijing");
        
        click([ 12, 135 ], [ 20, 120 ], 20, 0, "Singapore");
        a = 6.98;
        var x1 = -150,
            y1 = 65,
            z1 = 150,
            x1 = -5,
            y2 = -40;
        drawCircle( x1,y1,z1, x1, y2, "Singapore");
        _init(x1,y1,z1, x1, y2, "Singapore");
        parseNode(x1,y1,z1, x1, y2, "Singapore");
    }
  
    window.onload = init;
  
  
    function onMouseUp() {
        me = false;
        container.removeEventListener("mouseup", onMouseUp, false);
        container.style.cursor = "auto";
    }
    function onMouseDown(event) {
        event.preventDefault();
        me = true;
        container.addEventListener("mouseup", onMouseUp, false);
        pos.x = -event.clientX;
        pos.y = event.clientY;
        p.x = target.x;
        p.y = target.y;
        container.style.cursor = "move";
    }
    function onMouseMove(event) {
        if (me) {
            mouse.x = -event.clientX;
            mouse.y = event.clientY;
            var t = j / 1e3;
            target.x = p.x + .005 * (mouse.x - pos.x) * t;
            target.y = p.y + .005 * (mouse.y - pos.y) * t;
            target.y = target.y > PI_HALF ? PI_HALF : target.y;
            target.y = target.y < -PI_HALF ? -PI_HALF : target.y;
        } else {
            update(event);
        }
    }
    function move(event) {
        if (event.preventDefault(), me) {
            var touches = event.changedTouches;
            var i = 0;
            for (; i < touches.length; i++) {
                mouse.x = -touches[ i ].pageX;
                mouse.y = touches[ i ].pageY;
            }
            var t = j / 1e3;
            target.x = p.x + .005 * (mouse.x - pos.x) * t;
            target.y = p.y + .005 * (mouse.y - pos.y) * t;
            target.y = target.y > PI_HALF ? PI_HALF : target.y;
            target.y = target.y < -PI_HALF ? -PI_HALF : target.y;
        }
        return false;
    }
    var onMouseOut = function () {
        de = false;
        onMouseUp();
    };
  
    // 画地球
    function drawGlobe() {
        const textureLoader = new THREE.TextureLoader()//添加纹理
        const texture = textureLoader.load('./dist/img/world.png');
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            overdraw: .5,
            transparent: true,
            side: THREE.DoubleSide
        });
        var sphereGeometry = new THREE.SphereGeometry(200, 40, 30);
        mesh = new THREE.Mesh(sphereGeometry, material);
        mesh.name = "scene";
        mesh.rotation.y = .7 * Math.PI;
        mesh.receiveShadow = true;
        mesh.castShadow = true;
        scene.add(mesh);
    }
  
    function addLogo(px, py, pz, rx, ry, rz) {
        const textureLoader = new THREE.TextureLoader()
        // const texture = textureLoader.load('./dist/img/world_image_nansha.jpg');
        const texture = textureLoader.load('dist/img/mylogo.jpg');
        let geometry = new THREE.CircleGeometry(10, 16);
        var m = new THREE.MeshBasicMaterial({
            map: texture,
            overdraw: .5,
            transparent: true,
            side: THREE.DoubleSide
        });
        var r = new THREE.Mesh(geometry, m);
            r.position.set(px, py, pz);
            r.rotation.x = THREE.Math.degToRad(rx);
            r.rotation.y = THREE.Math.degToRad(ry);
            r.rotation.z = THREE.Math.degToRad(rz);
            r.name = "logo";
        scene.add(r);
    }
    function drawCircle(y, scale, center, angle, value, country) {
      var line = null;
      var geometry = new THREE.CircleGeometry(5, 64);
      var material = new THREE.LineBasicMaterial({
        color: '#DF5943'
      });
      geometry.vertices.shift();
      line = new THREE.LineLoop(geometry, material);
      line.position.set(y, scale, center);
      line.rotation.x = THREE.Math.degToRad(angle);
      line.rotation.y = THREE.Math.degToRad(value);
      line.name = "hollow-circle " + country;
      scene.add(line);
    }
    function parseNode(str, file, data, t, value, country) {
      var group = new THREE.CircleGeometry(20, 32);
      var m = new THREE.MeshBasicMaterial({
        color: '#DF5943',
        transparent: true,
        opacity: 0,
        side: THREE.DoubleSide
      });
      var r = new THREE.Mesh(group, m);
      r.position.set(str, file, data);
      r.rotation.x = THREE.Math.degToRad(t);
      r.rotation.y = THREE.Math.degToRad(value);
      r.name = "large-circle target=" + country;
      scene.add(r);
    }
    function click(e, f) {
        var type = arguments.length > 2 && void 0 !== arguments[ 2 ] ? arguments[ 2 ] : 20;
        var ngiScroll_timeout = arguments.length > 3 && void 0 !== arguments[ 3 ] ? arguments[ 3 ] : 0;
        var callbacks = arguments[ 4 ];
        setTimeout(function () {
            return parse(e, f, type, callbacks);
        }, ngiScroll_timeout);
    }
    
    function _init(height, html, option, data, value, title) {
      var t = new THREE.CircleGeometry(3, 10);
      var m = new THREE.MeshBasicMaterial({
        color: '#DF5943',
        side: THREE.DoubleSide
      });
      var r = new THREE.Mesh(t, m);
      r.position.set(height, html, option);
      r.rotation.x = THREE.Math.degToRad(data);
      r.rotation.y = THREE.Math.degToRad(value);
      /** @type {string} */
      r.name = "solid-circle target=" + title;
      scene.add(r);
    }
    function parse(m, data, name, value) {
      /**
       * @return {undefined}
       */
      function checkForToolTips() {
        if (!isStop) {
          /** @type {number} */
          i = (i + 1) % n;
          if (0 !== i) {
            line.geometry.setDrawRange(0, i);
            requestAnimationFrame(checkForToolTips);
          } else {
            translate({
              x: offset.v0x,
              y: offset.v0y,
              z: offset.v0z
            }, name, h);
          }
        }
      }
      
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var n = 200;
      /** @type {null} */
      var line = null;
      var node = new THREE.QuadraticBezierCurve3;
      var offset = set(m[ 0 ], m[ 1 ], data[ 0 ], data[ 1 ], value);
      node.v0 = new THREE.Vector3(offset.v0x, offset.v0y, offset.v0z);
      node.v1 = new THREE.Vector3(offset.v1x, offset.v1y, offset.v1z);
      node.v2 = new THREE.Vector3(offset.v2x, offset.v2y, offset.v2z);
      var h = node.getPoints(name);
      var path2 = node.getPoints(n);
      var geometry = new THREE.BufferGeometry;
      /** @type {!Float32Array} */
      var line_positions = new Float32Array(3 * n);
      geometry.addAttribute("position", new THREE.BufferAttribute(line_positions, 3));
      /** @type {number} */
      i = 2;
      geometry.setDrawRange(0, i);
      var linematerial = new THREE.LineBasicMaterial({
        color: '#DF5943',
        linewidth: 1
      });
      line = new THREE.Line(geometry, linematerial);
      (function (e, vertexes) {
        var p = line.geometry.attributes.position.array;
        /** @type {number} */
        var n = 0;
        /** @type {number} */
        var i = 0;
        /** @type {number} */
        var ub = e;
        for (; i < ub; i++) {
          p[ n++ ] = vertexes[ i ].x;
          p[ n++ ] = vertexes[ i ].y;
          p[ n++ ] = vertexes[ i ].z;
        }
      })(n, path2);
      scene.add(line);
      checkForToolTips();
    }
    function set(x, y, m, d, name) {
      var MinimumContentImageWidthToArticleWidthRatio = 0;
      var s = 200 * Math.sin(x / 180 * Math.PI);
      MinimumContentImageWidthToArticleWidthRatio = 200 * Math.cos(x / 180 * Math.PI);
      var maximumImageArea = Math.cos(y / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
      var maxDistanceToConsiderSimilar = Math.sin(y / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
      var u = 200 * Math.sin(m / 180 * Math.PI);
      MinimumContentImageWidthToArticleWidthRatio = 200 * Math.cos(m / 180 * Math.PI);
      var topBottomIgnoreDistance = Math.cos(d / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
      var imageMinimumWidth = Math.sin(d / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
      var c = center({
        v0x: maximumImageArea,
        v0y: s,
        v0z: maxDistanceToConsiderSimilar
      }, {
        v2x: topBottomIgnoreDistance,
        v2y: u,
        v2z: imageMinimumWidth
      }, name);
      return {
        v0x: maximumImageArea,
        v0y: s,
        v0z: maxDistanceToConsiderSimilar,
        v1x: c.v1x,
        v1y: c.v1y,
        v1z: c.v1z,
        v2x: topBottomIgnoreDistance,
        v2y: u,
        v2z: imageMinimumWidth
      };
    }
    function center(params, value, length) {
      var l = params.v0x;
      var minimap_selfCharacter_zone_y = params.v0y;
      var t = params.v0z;
      var m = value.v2x;
      var minimap_character_zone_y = value.v2y;
      var x = value.v2z;
      /** @type {number} */
      var max = (l + m) / 2;
      /** @type {number} */
      var i = (minimap_selfCharacter_zone_y + minimap_character_zone_y) / 2;
      /** @type {number} */
      var v0 = (t + x) / 2;
      /** @type {number} */
      var psisq = Math.sqrt(Math.pow(m - l, 2) + Math.pow(minimap_character_zone_y - minimap_selfCharacter_zone_y, 2) + Math.pow(x - t, 2));
      /** @type {number} */
      var d = Math.pow(psisq, 2) / (Math.pow(max, 2) + Math.pow(i, 2) + Math.pow(v0, 2));
      /** @type {boolean} */
      var f = false;
      if (d > 3 && d < 10) {
        /** @type {number} */
        d = 2;
      } else {
        if (d > 10) {
          /** @type {number} */
          d = 14;
          /** @type {boolean} */
          f = true;
        }
      }
      /** @type {number} */
      var n = max + d * max / 2;
      /** @type {number} */
      var e = i + d * i / 2;
      /** @type {number} */
      var vc = v0 + d * v0 / 2;
      return "Mexico" === length && (n = max + d * max * .7, e = i + d * i * .7, vc = v0 + d * v0 * .7), "Brazil" === length && (n = max + d * max * .4, e = i + d * i * .4, vc = v0 + d * v0 * .4), f && (n = n - 250, e = e -
        50, vc = vc - 20), {
        v1x: n,
        v1y: e,
        v1z: vc
      };
    }
    function translate(x, s, v) {
      var n = new THREE.Mesh(t, multiply);
      n.position.set(x.x, x.y, x.z);
      scene.add(n);
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      initializeCheckTimer = setInterval(function () {
        i++;
        if (i > s) {
          /** @type {number} */
          i = 0;
        } else {
          n.position.set(v[ i ].x, v[ i ].y, v[ i ].z);
        }
      }, 50);
    }
    function update(event) {
    }
</script>
</body>
</html>
