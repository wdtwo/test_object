<html>
<head>
  <title></title>
  <meta charset="UTF-8"/>
  <script src="three.js"></script>
</head>
<body>
<div id="container" style="color: rgb(255, 255, 255);"></div>
<script>
  var SCREEN_WIDTH = null;
  var SCREEN_HEIGHT = null;
  var scene = null;
  var mesh = null;
  var camera = null;
  var renderer = null;
  var container = document.getElementById('container')
  var me = false
  var mouse = new THREE.Vector2;
  var pos = {
    x: 0,
    y: 0
  };
  var rotation = {
    x: 0,
    y: 0
  };
  var target = {
    x: 2.1 * Math.PI,
    y: Math.PI / 4.5
  };
  var p = {
    x: 0,
    y: 0
  };
  var de = false;

  var type = "";
  var node = "";
  //网页加载完毕后会被调用
  function init() {
    SCREEN_WIDTH = width();
    SCREEN_HEIGHT = width();
    //创建一个场景（场景是一个容器，用于保存、跟踪所要渲染的物体和使用的光源）
    scene = new THREE.Scene();
    //创建一个摄像机对象
    camera = new THREE.PerspectiveCamera(30,1, 1, 1e4);
    camera.position.x = 30;
    camera.position.y = 30;
    camera.position.z = 30;
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    scene.add(new THREE.AmbientLight('#e05943'));
    //创建一个WebGL渲染器并设置其大小
    renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    // renderer.setClearColor(new THREE.Color(0x00000)); //0xc0c0c0
    // renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;

    //将渲染的结果输出到指定页面元素中
    container.appendChild(renderer.domElement);
    
    // container.addEventListener("mousedown", onMouseDown, false);
    // container.addEventListener("mouseleave", onMouseOut, false);
    // container.addEventListener("mousemove", onMouseMove, false);
    //container.addEventListener("mouseenter", scroll, false);
    
    container.addEventListener("touchstart", start, false);
    container.addEventListener("touchend", onMouseWheel, false);
    container.addEventListener("touchmove", move, false);
    // window.addEventListener("resize", resize, false);

    //坐标系
    var axesHelper=new THREE.AxesHelper(100);
        //axesHelper.position.set(0,100,0);
        scene.add(axesHelper);


    drawGlobe()
    var pos = [ 
        [ 42, 122 ], 
        [ 2, 130 ], 
        [ 22, 156.5 ], 
        [ 24.5, 179 ], 
        [ -24, -77 ], 
        [ 50, -202 ], //东亚
        [ 36.1, -6.41 ],
        [ 25, -25 ], 
        [ 10, 110 ], //菲律宾
        [ 40, 105],  //韩国
        [ -32, -56 ], 
        [ 5, -52 ], 
        [ 10, -41.6 ] ,
        ];
    let a = 138.68;
    addLogo(-.494 * a, a, .914 * a, -50, -20, -18);
    //drawCircle(-.494 * a, a, .914 * a, -50, -20, "Beijing");
    parseNode(-.494 * a, a, .914 * a, -50, -20, "Beijing");

    a = 138.78;
    create(-.494 * a, a, .914 * a, -50, -20, "Beijing");
    

    a = 6.98;
    click([ 40, 120 ], pos[ 1 ], 20, 0, "新加坡");
    drawCircle(-18.407 * a, a, 21.9366 * a, -5, -40, "新加坡");
    _init(-18.407 * a, a, 21.9366 * a, -5, -40, "新加坡");
    parseNode(-18.407 * a, a, 21.9366 * a, -5, -40, "新加坡");
    a = 7;
    create(-18.407 * a, a, 21.9366 * a, -5, -40, "新加坡");

    create(-2.19397 * a, a, .0382956 * a, -81, -65, "埃塞尔比亚");
    click([ 42, 122 ], pos[ 3 ], 35, 1e3, "埃塞尔比亚");
    drawCircle(-182.1, 83, 3.18, -81, -65, "埃塞尔比亚");
    _init(-182.1, 83, 3.18, -81, -65, "埃塞尔比亚");
    parseNode(-182.1, 83, 3.18, -81, -65, "埃塞尔比亚");      
    
    var x = -168,
        y = 77.5,
        z = 78,
        s = -35,
        w = -65
    click([ 42, 122 ], pos[ 2 ], 30, 500, "南亚");
    drawCircle(x,y,z,s,w, "南亚");
    _init(x,y,z,s,w, "南亚");
    parseNode(x,y,z,s,w, "南亚");
    create(x,y,z,s,w, "南亚");
    var x = -100,
        y = 164.5,
        z = 58,
        s = -85,
        w = -35;
    click([ 47, 122 ], [55, -210], 40, 100, "东亚");
    drawCircle(x, y, z, s, w, "东亚");
    _init(x, y, z, s, w, "东亚");
    parseNode(x, y, z, s, w, "东亚");
    create(x, y, z, s, w, "东亚");

    var x = -68,
        y = 35,
        z = 186,
        s = -10,
        w = 160
    click([ 42, 118 ], pos[ 8 ], 25, 2500, "菲律宾");
    drawCircle(x, y, z, s, w, "菲律宾");
    _init(x, y, z, s, w, "菲律宾");
    parseNode(x, y, z, s, w, "菲律宾");
    create(x, y, z, s, w, "菲律宾");
    
    var x = -41,
        y = 129.5,
        z = 147,
        s = -40,
        w = -10
    click([ 43, 115 ], pos[ 9 ], 25, 500, "韩国"); 
    drawCircle(x, y, z, s, w, "韩国");
    _init(x, y, z, s, w, "韩国");
    parseNode(x, y, z, s, w, "韩国");
    create(x, y, z, s, w, "韩国");
    
    var x = -193.5,
        y = 4,
        z = -50,
        s = 165,
        w = 102;
    //click([ 45, 118 ], [-31.3,-150.8], 40, 100, "非洲");
    click([ 45, 118 ], [0,-165], 40, 100, "非洲");
    drawCircle(x, y, z, s, w, "非洲");
    _init(x, y, z, s, w, "非洲");
    parseNode(x, y, z, s, w, "非洲");
    create(x, y, z, s, w, "非洲");
    
    var x = -150,
        y = 57,
        z = -120,
        s = 24,
        w = 52;
    click([ 45, 118 ], [15,-140], 40, 100, "尼日利亚");
    drawCircle(x, y, z, s, w, "尼日利亚");
    _init(x, y, z, s, w, "尼日利亚");
    parseNode(x, y, z, s, w, "尼日利亚");
    create(x, y, z, s, w, "尼日利亚");
    
    function createText(str,arr1,arr2,size,color) {
            var text = new THREE.FontLoader().load('./font.json', function(text) {
                var gem = new THREE.TextGeometry(str, {
                    size: size, //字号大小，一般为大写字母的高度
                    height: 0.01, //文字的厚度
                    weight: 'normal', //值为'normal'或'bold'，表示是否加粗
                    font: text, //字体，默认是'helvetiker'，需对应引用的字体文件
                    style: 'normal', //值为'normal'或'italics'，表示是否斜体
                    bevelThickness: 1, //倒角厚度
                    bevelSize: 1, //倒角宽度
                    curveSegments: 0,//弧线分段数，使得文字的曲线更加光滑
                    bevelEnabled: false, //布尔值，是否使用倒角，意为在边缘处斜切
                });
                gem.center();
                var mat = new THREE.MeshPhongMaterial({
                    color: color,
                    //specular: 0xff0000,
                    //shininess: 10,
                    //shading: THREE.FlatShading
                });
                //var textObj = new THREE.Mesh(gem, mat);
                //textObj.castShadow = true;
                
                var r = new THREE.Mesh(gem, mat);
                r.position.set(arr1[0],arr1[1],arr1[2]); //位置坐标
                r.rotation.x = THREE.Math.degToRad(arr2[0]); //旋转方向
                r.rotation.y = THREE.Math.degToRad(arr2[1]);
                r.rotation.z = THREE.Math.degToRad(arr2[2]);
                scene.add(r);
            });
        }
    
    
    createText('中国总部',[-80,120,145],[-30,-32,-14],10,0xE05943);
    createText('菲律宾',[-50,30,192],[0,-15,0],5,0xE05943);
    createText('韩国',[-30,140,145],[-40,-15,-14],5,0xE05943);
    createText('东南亚',[-110,-5,170],[0,-40,0],5,0xE05943);
    createText('南亚',[-163,70,95],[-5,-60,-5],5,0xE05943);
    createText('东亚',[-90,167,70],[-60,-45,-40],5,0xE05943);
    createText('埃塞尔比亚',[-187,70,20],[-80,-60,-80],5,0xE05943);
    createText('非洲',[-198,0,-35],[-80,-95,-80],5,0xE05943);
    createText('尼日利亚',[-151,40,-125],[0,-130,0],5,0xE05943);
  }


  function drawCircle(y, scale, center, angle, value, country) {
    /** @type {null} */
    var line = null;
    var geometry = new THREE.CircleGeometry(5, 64);
    var material = new THREE.LineBasicMaterial({
      color: '#e05943'
    });
    geometry.vertices.shift();
    line = new THREE.LineLoop(geometry, material);
    line.position.set(y, scale, center);
    line.rotation.x = THREE.Math.degToRad(angle);
    line.rotation.y = THREE.Math.degToRad(value);
    line.name = "hollow-circle " + country;
    scene.add(line);
  }

  function addLogo(px, py, pz, rx, ry, rz) {
    const textureLoader = new THREE.TextureLoader()
    // const texture = textureLoader.load('dist/img/world_image_nansha.jpg');
    const texture = textureLoader.load('dist/img/mylogo.jpg');
    let geometry = new THREE.CircleGeometry(15, 32);
    var m = new THREE.MeshBasicMaterial({
      map: texture,
      overdraw: .5,
      transparent: true,
      side: THREE.DoubleSide
    });
    var r = new THREE.Mesh(geometry, m);
    r.position.set(px, py, pz);
    r.rotation.x = THREE.Math.degToRad(rx);
    r.rotation.y = THREE.Math.degToRad(ry);
    r.rotation.z = THREE.Math.degToRad(rz);
    r.name = "logo";
    scene.add(r);
  }

  function parseNode(str, file, data, t, value, country) {
    var group = new THREE.CircleGeometry(10, 32);
    var m = new THREE.MeshBasicMaterial({
      color: '#e05943',
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    var r = new THREE.Mesh(group, m);
    r.position.set(str, file, data);
    r.rotation.x = THREE.Math.degToRad(t);
    r.rotation.y = THREE.Math.degToRad(value);
    r.name = "large-circle target=" + country;
    scene.add(r);
  }


  function create(array, html, id, angle, value, country) {
    /**
     * @return {undefined}
     */
    function add() {
      occlusion = occlusion + .01;
      if (occlusion > 2) {
        /** @type {number} */
        occlusion = 1;
      }
      body.scale.x = occlusion;
      body.scale.y = occlusion;
      /** @type {number} */
      body.material.opacity = type && type === country ? .3 : node && node === country ? .3 : 0;
      requestAnimationFrame(add);
    }

    var bodyGeom = new THREE.CircleGeometry(5, 40);
    var bodyMat = new THREE.MeshBasicMaterial({
      color: '#e05943',
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide
    });
    var body = new THREE.Mesh(bodyGeom, bodyMat);
    body.position.set(array, html, id);
    body.rotation.x = THREE.Math.degToRad(angle);
    body.rotation.y = THREE.Math.degToRad(value);
    /** @type {string} */
    body.name = "twinklin-light target=" + country;
    scene.add(body);
    /** @type {number} */
    var occlusion = 1;
    add();
  }

  function _init(height, html, option, data, value, title) {
    var t = new THREE.CircleGeometry(3, 32);
    var m = new THREE.MeshBasicMaterial({
      color: '#e05943',
      side: THREE.DoubleSide
    });
    var r = new THREE.Mesh(t, m);
    r.position.set(height, html, option);
    r.rotation.x = THREE.Math.degToRad(data);
    r.rotation.y = THREE.Math.degToRad(value);
    /** @type {string} */
    r.name = "solid-circle target=" + title;
    scene.add(r);
  }

  function createAutoComplete(config) {
    var rotateAxisVector = {};
    var previousReading = {};
    var unitCube = {};
    var length = void 0;
    var d = void 0;
    var scale = void 0;
    switch (config) {
      case "CostaRica":
        /** @type {number} */
        length = 200;
        rotateAxisVector = {
          x: -1.2 * length,
          y: length,
          z: -.2 * length
        };
        /** @type {number} */
        d = 177;
        previousReading = {
          x: d,
          y: 2.2 * d,
          z: -.5 * d
        };
        /** @type {number} */
        scale = 41.7;
        unitCube = {
          x: 3.4 * scale,
          y: -1e-5 * scale,
          z: -3.2 * scale
        };
        break;
      case "Colombia":
        /** @type {number} */
        length = 200;
        rotateAxisVector = {
          x: -1.2 * length,
          y: length,
          z: -.2 * length
        };
        /** @type {number} */
        d = 170;
        previousReading = {
          x: -.3 * d,
          y: 1.75 * d,
          z: -.5 * d
        };
        /** @type {number} */
        scale = 60;
        unitCube = {
          x: scale,
          y: 2.8 * scale,
          z: -3.2 * scale
        };
        break;
      case "Chile":
        /** @type {number} */
        length = 190;
        rotateAxisVector = {
          x: -1.3472 * length,
          y: length,
          z: -.1773 * length
        };
        /** @type {number} */
        d = 180;
        previousReading = {
          x: -1 * d,
          y: 1.5 * d,
          z: -.1773 * d
        };
        /** @type {number} */
        scale = 50;
        unitCube = {
          x: -1.2762 * scale,
          y: scale,
          z: -7.2133 * scale
        };
        break;
      case "Brazil":
        /** @type {number} */
        length = 190;
        rotateAxisVector = {
          x: -1.3472 * length,
          y: length,
          z: -.1773 * length
        };
        /** @type {number} */
        d = 180;
        previousReading = {
          x: -1.3472 * d,
          y: d,
          z: -.1773 * d
        };
        /** @type {number} */
        scale = 30;
        unitCube = {
          x: -6.2762 * scale,
          y: scale,
          z: -9.2133 * scale
        };
        break;
      case "Mexico":
        /** @type {number} */
        length = 210;
        rotateAxisVector = {
          x: .429 * length,
          y: length,
          z: .225 * length
        };
        /** @type {number} */
        d = 200;
        previousReading = {
          x: .046 * d,
          y: d,
          z: .511 * d
        };
        /** @type {number} */
        scale = 167;
        unitCube = {
          x: .8864 * scale,
          y: scale,
          z: -.1169 * scale
        };
        break;
      default:
        unitCube = {};
    }
    return {
      topPointer: rotateAxisVector,
      secondDot: previousReading,
      fourDot: unitCube
    };
  }

  function center(params, value, length) {
    var l = params.v0x;
    var minimap_selfCharacter_zone_y = params.v0y;
    var t = params.v0z;
    var m = value.v2x;
    var minimap_character_zone_y = value.v2y;
    var x = value.v2z;
    /** @type {number} */
    var max = (l + m) / 2;
    /** @type {number} */
    var i = (minimap_selfCharacter_zone_y + minimap_character_zone_y) / 2;
    /** @type {number} */
    var v0 = (t + x) / 2;
    /** @type {number} */
    var psisq = Math.sqrt(Math.pow(m - l, 2) + Math.pow(minimap_character_zone_y - minimap_selfCharacter_zone_y, 2) + Math.pow(x - t, 2));
    /** @type {number} */
    var d = Math.pow(psisq, 2) / (Math.pow(max, 2) + Math.pow(i, 2) + Math.pow(v0, 2));
    /** @type {boolean} */
    var f = false;
    if (d > 3 && d < 10) {
      /** @type {number} */
      d = 2;
    } else {
      if (d > 10) {
        /** @type {number} */
        d = 14;
        /** @type {boolean} */
        f = true;
      }
    }
    /** @type {number} */
    var n = max + d * max / 2;
    /** @type {number} */
    var e = i + d * i / 2;
    /** @type {number} */
    var vc = v0 + d * v0 / 2;
    return "Mexico" === length && (n = max + d * max * .7, e = i + d * i * .7, vc = v0 + d * v0 * .7), "Brazil" === length && (n = max + d * max * .4, e = i + d * i * .4, vc = v0 + d * v0 * .4), f && (n = n - 250, e = e -
      50, vc = vc - 20), {
      v1x: n,
      v1y: e,
      v1z: vc
    };
  }

  function set(x, y, m, d, name) {
    var MinimumContentImageWidthToArticleWidthRatio = 0;
    var s = 200 * Math.sin(x / 180 * Math.PI);
    MinimumContentImageWidthToArticleWidthRatio = 200 * Math.cos(x / 180 * Math.PI);
    var maximumImageArea = Math.cos(y / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
    var maxDistanceToConsiderSimilar = Math.sin(y / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
    var u = 200 * Math.sin(m / 180 * Math.PI);
    MinimumContentImageWidthToArticleWidthRatio = 200 * Math.cos(m / 180 * Math.PI);
    var topBottomIgnoreDistance = Math.cos(d / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
    var imageMinimumWidth = Math.sin(d / 180 * Math.PI) * MinimumContentImageWidthToArticleWidthRatio;
    var c = center({
      v0x: maximumImageArea,
      v0y: s,
      v0z: maxDistanceToConsiderSimilar
    }, {
      v2x: topBottomIgnoreDistance,
      v2y: u,
      v2z: imageMinimumWidth
    }, name);
    return {
      v0x: maximumImageArea,
      v0y: s,
      v0z: maxDistanceToConsiderSimilar,
      v1x: c.v1x,
      v1y: c.v1y,
      v1z: c.v1z,
      v2x: topBottomIgnoreDistance,
      v2y: u,
      v2z: imageMinimumWidth
    };
  }

  var t = new THREE.SphereGeometry(3, 20, 20);
  var multiply = new THREE.MeshBasicMaterial({
    color: '#e05943'
  });

  function translate(x, s, v) {
    var n = new THREE.Mesh(t, multiply);
    n.position.set(x.x, x.y, x.z);
    scene.add(n);
    /** @type {number} */
    var i = 0;
    /** @type {number} */
    initializeCheckTimer = setInterval(function () {
      i++;
      if (i > s) {
        /** @type {number} */
        i = 0;
      } else {
        n.position.set(v[ i ].x, v[ i ].y, v[ i ].z);
      }
    }, 50);
  }

  function click(e, f) {
    var type = arguments.length > 2 && void 0 !== arguments[ 2 ] ? arguments[ 2 ] : 20;
    var ngiScroll_timeout = arguments.length > 3 && void 0 !== arguments[ 3 ] ? arguments[ 3 ] : 0;
    var callbacks = arguments[ 4 ];
    setTimeout(function () {
      return parse(e, f, type, callbacks);
    }, ngiScroll_timeout);
  }

  function parse(m, data, name, value) {
    /**
     * @return {undefined}
     */
    function checkForToolTips() {
      if (!isStop) {
        /** @type {number} */
        i = (i + 1) % n;
        if (0 !== i) {
          line.geometry.setDrawRange(0, i);
          requestAnimationFrame(checkForToolTips);
        } else {
          translate({
            x: offset.v0x,
            y: offset.v0y,
            z: offset.v0z
          }, name, h);
        }
      }
    }

    /** @type {number} */
    var i = 0;
    /** @type {number} */
    var n = 200;
    /** @type {null} */
    var line = null;
    var node = new THREE.QuadraticBezierCurve3;
    var offset = set(m[ 0 ], m[ 1 ], data[ 0 ], data[ 1 ], value);
    node.v0 = new THREE.Vector3(offset.v0x, offset.v0y, offset.v0z);
    node.v1 = new THREE.Vector3(offset.v1x, offset.v1y, offset.v1z);
    node.v2 = new THREE.Vector3(offset.v2x, offset.v2y, offset.v2z);
    var h = node.getPoints(name);
    var path2 = node.getPoints(n);
    var geometry = new THREE.BufferGeometry;
    /** @type {!Float32Array} */
    var line_positions = new Float32Array(3 * n);
    geometry.addAttribute("position", new THREE.BufferAttribute(line_positions, 3));
    /** @type {number} */
    i = 2;
    geometry.setDrawRange(0, i);
    var linematerial = new THREE.LineBasicMaterial({
      color: '#e05943',
      linewidth: 1
    });
    line = new THREE.Line(geometry, linematerial);
    (function (e, vertexes) {
      var p = line.geometry.attributes.position.array;
      /** @type {number} */
      var n = 0;
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var ub = e;
      for (; i < ub; i++) {
        p[ n++ ] = vertexes[ i ].x;
        p[ n++ ] = vertexes[ i ].y;
        p[ n++ ] = vertexes[ i ].z;
      }
    })(n, path2);
    scene.add(line);
    checkForToolTips();
  }

  /**
   * @return {undefined}
   */
  var scroll = function () {
    /** @type {boolean} */
    de = true;
  };
  var onMouseOut = function () {
    /** @type {boolean} */
    de = false;
    onMouseUp();
  };
  var PI_HALF = Math.PI / 2;

  function move(event) {
    if (event.preventDefault(), me) {
      var touches = event.changedTouches;
      /** @type {number} */
      var i = 0;
      for (; i < touches.length; i++) {
        /** @type {number} */
        mouse.x = -touches[ i ].pageX;
        mouse.y = touches[ i ].pageY;
      }
      /** @type {number} */
      var t = j / 1e3;
      target.x = p.x + .005 * (mouse.x - pos.x) * t;
      target.y = p.y + .005 * (mouse.y - pos.y) * t;
      target.y = target.y > PI_HALF ? PI_HALF : target.y;
      target.y = target.y < -PI_HALF ? -PI_HALF : target.y;
    }
    return false;
  }

  function onMouseMove(event) {
    if (me) {
      /** @type {number} */
      mouse.x = -event.clientX;
      mouse.y = event.clientY;
      /** @type {number} */
      var t = j / 1e3;
      target.x = p.x + .005 * (mouse.x - pos.x) * t;
      target.y = p.y + .005 * (mouse.y - pos.y) * t;
      target.y = target.y > PI_HALF ? PI_HALF : target.y;
      target.y = target.y < -PI_HALF ? -PI_HALF : target.y;
    } else {
      update(event);
    }
  }

  function abs(url) {
    /** @type {boolean} */
    type = url;
  }

  function update(event) {
  }

  function getDistance() {
    /** @type {string} */
    type = "";
  }

  function resize() {
    setTimeout(function () {
      var w = width();
      /** @type {number} */
      camera.aspect = w / w;
      camera.updateProjectionMatrix();
      renderer.setSize(w, w);
    }, 300);
  }

  function onMouseDown(event) {
    event.preventDefault();
    /** @type {boolean} */
    me = true;
    container.addEventListener("mouseup", onMouseUp, false);
    /** @type {number} */
    pos.x = -event.clientX;
    pos.y = event.clientY;
    p.x = target.x;
    p.y = target.y;
    /** @type {string} */
    container.style.cursor = "move";
  }

  function onMouseUp() {
    me = false;
    container.removeEventListener("mouseup", onMouseUp, false);
    container.style.cursor = "auto";
  }

  var getMousePosition = function (dom, x, y) {
    var rect = dom.getBoundingClientRect();
    return [ (x - rect.left) / rect.width, (y - rect.top) / rect.height ];
  }

  function width() {
      return window.innerWidth-200;
  }
  function reset(object, args) {
    var ngiScroll_timeout = arguments.length > 2 && void 0 !== arguments[ 2 ] ? arguments[ 2 ] : 0;
    var value = arguments[ 3 ];
    var parser = new THREE.Geometry;
    var curve = new THREE.QuadraticBezierCurve3;
    var p2 = set(object[ 0 ], object[ 1 ], args[ 0 ], args[ 1 ], value);
    curve.v0 = new THREE.Vector3(p2.v0x, p2.v0y, p2.v0z);
    curve.v1 = new THREE.Vector3(p2.v1x, p2.v1y, p2.v1z);
    curve.v2 = new THREE.Vector3(p2.v2x, p2.v2y, p2.v2z);
    /** @type {number} */
    for (var i = 0; i <= 40; i++) {
      parser.vertices.push(curve.getPoint(i / 40));
    }
    var node = createAutoComplete(value);
    var nodes = parser.vertices;
    setTimeout(function () {
      return renderLine(nodes[ 0 ], node.secondDot, node.topPointer, node.fourDot, nodes[ 40 ]);
    }, ngiScroll_timeout);
  }

  var isStop = false;

  function renderLine(pos, scale, name, n, start) {
    function checkForToolTips() {
      if (!isStop) {
        /** @type {number} */
        a = (a + 1) % b;
        if (0 !== a) {
          line.geometry.setDrawRange(0, a);
          requestAnimationFrame(checkForToolTips);
        } else {
          translate(pos, id, m);
        }
      }
    }

    /** @type {number} */
    var a = 0;
    /** @type {number} */
    var b = 300;
    /** @type {null} */
    var line = null;
    var inner = new THREE.CubicBezierCurve3(new THREE.Vector3(pos.x, pos.y, pos.z), new THREE.Vector3(scale.x, scale.y, scale.z), new THREE.Vector3(n.x, n.y, n.z), new THREE.Vector3(start.x, start.y, start.z));
    /** @type {number} */
    var id = 50;
    var m = inner.getPoints(id);
    var item = inner.getPoints(b);
    var geometry = new THREE.BufferGeometry;
    /** @type {!Float32Array} */
    var line_positions = new Float32Array(3 * b);
    geometry.addAttribute("position", new THREE.BufferAttribute(line_positions, 3));
    /** @type {number} */
    a = 2;
    geometry.setDrawRange(0, a);
    var linematerial = new THREE.LineBasicMaterial({
      color: '#e05943',
      linewidth: 1
    });
    line = new THREE.Line(geometry, linematerial);
    (function (type, data) {
      var p = line.geometry.attributes.position.array;
      /** @type {number} */
      var n = 0;
      /** @type {number} */
      var id = 0;
      /** @type {number} */
      var graphTypeBaseName = type;
      for (; id < graphTypeBaseName; id++) {
        p[ n++ ] = data[ id ].x;
        p[ n++ ] = data[ id ].y;
        p[ n++ ] = data[ id ].z;
      }
    })(b, item);
    scene.add(line)
    checkForToolTips();

  }

  // 画地球
  function drawGlobe() {
    const textureLoader = new THREE.TextureLoader()
    const texture = textureLoader.load('dist/img/world_image_nansha.png');
    const material = new THREE.MeshBasicMaterial({
      map: texture,
      overdraw: .5,
      transparent: true,
      side: THREE.DoubleSide
    });
    var sphereGeometry = new THREE.SphereGeometry(200, 40, 30);
    mesh = new THREE.Mesh(sphereGeometry, material);
    mesh.name = "scene";
    mesh.rotation.y = .7 * Math.PI;
    mesh.receiveShadow = true;
    mesh.castShadow = true;
    scene.add(mesh);
  }


  var step = 0;
  // var a = 138.68;

  var viewX = 0;
  var x = 1e3;
  var j = 1e3;

  function applyForEach(viewX) {
    /** @type {number} */
    x = x - viewX;
    x = x > 1e3 ? 1e3 : x;
    x = x < 350 ? 350 : x;
  }

  var rotation = {
    x: 0,
    y: 0
  };
  var target = {
    x: 2.1 * Math.PI,
    y: Math.PI / 4.5
  };
  var be = 0;
  var we = true;

  function render() {
    applyForEach(viewX);

    if (we) {
      if (be === target.x + target.y) {
        target.x -= .00005;
      } else {
        be = target.x + target.y;
      }
      rotation.x += .1 * (target.x - rotation.x);
      rotation.y += .1 * (target.y - rotation.y);
      j = j + .3 * (x - j);
      /** @type {number} */
      camera.position.x = j * Math.sin(rotation.x) * Math.cos(rotation.y);
      /** @type {number} */
      camera.position.y = j * Math.sin(rotation.y);
      /** @type {number} */
      camera.position.z = j * Math.cos(rotation.x) * Math.cos(rotation.y);
    }
    // mesh.material.uniforms.time.value += 0.1;
    camera.lookAt(mesh.position);
    // requestAnimationFrame(render);
    renderer.render(scene, camera);
  }

  function animation() {
    if (!isStop) {
      requestAnimationFrame(animation);
      //render();
    }
  }

  //确保init方法在网页加载完毕后被调用
  window.onload = init;
  animation()
</script>
</body>
</html>
